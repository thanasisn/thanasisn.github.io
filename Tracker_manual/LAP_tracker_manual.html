<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Εγχειρίδιο λειτουργίας ηλιοστάτη.</title>
  <meta name="description" content="Εγχειρίδιο λειτουργίας ηλιοστάτη." />
  <meta name="generator" content="bookdown 0.42 and GitBook 2.6.7" />

  <meta property="og:title" content="Εγχειρίδιο λειτουργίας ηλιοστάτη." />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Εγχειρίδιο λειτουργίας ηλιοστάτη." />
  
  
  

<meta name="author" content="Thanasisn github.com/thanasisn" />


<meta name="date" content="2025-02-19" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  <link rel="shortcut icon" href="files/P1110595e2.png" type="image/x-icon" />


<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<p> </p>
<div class="logos" align="center"><img src="files/P1110595e2.png" width="80px" align="center"></div>
<li align="center">LAP tracker manual</li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path=""><a href="#intro"><i class="fa fa-check"></i>Εισαγωγή.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#tracker"><i class="fa fa-check"></i>Ο ηλιοστάτης του Εργαστηρίου Φυσικής της Ατμόσφαιρας.</a>
<ul>
<li class="chapter" data-level="" data-path=""><a href="#trackerdescription"><i class="fa fa-check"></i>Περιγραφή tracker (ηλιοστάτη).</a></li>
<li class="chapter" data-level="" data-path=""><a href="#tracker_communication"><i class="fa fa-check"></i>Επικοινωνία με τον tracker.</a>
<ul>
<li class="chapter" data-level="" data-path=""><a href="#tracker_matlab"><i class="fa fa-check"></i>Επικοινωνία με τον Tracker σε περιβάλλον MatLab</a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#tracker_connection"><i class="fa fa-check"></i>Συνδεσμολογία</a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#trackeroperation"><i class="fa fa-check"></i>Λειτουργία - Προγραμματισμός tracker.</a>
<ul>
<li class="chapter" data-level="" data-path=""><a href="#γενικές-πληροφορίες"><i class="fa fa-check"></i>Γενικές πληροφορίες</a></li>
<li class="chapter" data-level="" data-path=""><a href="#παράμετροι-επικοινωνίας-με-τον-microcontroller-του-tracker."><i class="fa fa-check"></i>Παράμετροι επικοινωνίας με τον microcontroller του tracker.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#εντολές-tracker."><i class="fa fa-check"></i>Εντολές tracker.</a>
<ul>
<li class="chapter" data-level="" data-path=""><a href="#μορφή-εντολών-format."><i class="fa fa-check"></i>Μορφή εντολών (format).</a></li>
<li class="chapter" data-level="" data-path=""><a href="#μηδενισμός-του-βήματος-του-microcontroller."><i class="fa fa-check"></i>Μηδενισμός του βήματος του microcontroller.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#κίνηση-των-αξόνων"><i class="fa fa-check"></i>Κίνηση των αξόνων</a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#permissions-to-access-usb-serial-σε-gnulinux."><i class="fa fa-check"></i>Permissions to access USB serial σε GNU/Linux.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#resetting-usbserial-interface-σε-gnulinux."><i class="fa fa-check"></i>Resetting USB/serial interface σε GNU/Linux.</a>
<ul>
<li class="chapter" data-level="" data-path=""><a href="#αποσύνδεση-των-αντίστοιχων-modulefirmware-από-τον-kernel."><i class="fa fa-check"></i>Αποσύνδεση των αντίστοιχων module/firmware από τον kernel.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#αποσύνδεση-της-συσκευής-από-το-σύστημα."><i class="fa fa-check"></i>Αποσύνδεση της συσκευής από το σύστημα.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#αποσύνδεση-του-mountpoint-από-το-σύστημα-untested."><i class="fa fa-check"></i>Αποσύνδεση του mountpoint από το σύστημα (untested).</a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#προγραμματισμός"><i class="fa fa-check"></i>Προγραμματισμός</a>
<ul>
<li class="chapter" data-level="" data-path=""><a href="#python"><i class="fa fa-check"></i>Python</a></li>
<li class="chapter" data-level="" data-path=""><a href="#sun_tracker_main.py"><i class="fa fa-check"></i><code>sun_tracker_main.py</code></a></li>
<li class="chapter" data-level="" data-path=""><a href="#sun_vector_astropy.py-και-sun_vector_ephem.py"><i class="fa fa-check"></i><code>sun_vector_astropy.py</code> και <code>sun_vector_ephem.py</code></a></li>
<li class="chapter" data-level="" data-path=""><a href="#param_location.py"><i class="fa fa-check"></i><code>param_location.py</code></a></li>
<li class="chapter" data-level="" data-path=""><a href="#tracker_functions.py"><i class="fa fa-check"></i><code>tracker_functions.py</code></a></li>
<li class="chapter" data-level="" data-path=""><a href="#tracker_sighting_no_ui_tcp-port.py"><i class="fa fa-check"></i><code>tracker_sighting_no_ui_tcp-port.py</code></a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#ηλεκτρικά---μηχανικά-χαρακτηριστικά."><i class="fa fa-check"></i>Ηλεκτρικά - Μηχανικά Χαρακτηριστικά.</a>
<ul>
<li class="chapter" data-level="" data-path=""><a href="#κινητήρες-tracker-57sh56-4am"><i class="fa fa-check"></i>Κινητήρες tracker (57SH56-4AM)</a></li>
<li class="chapter" data-level="" data-path=""><a href="#κινητήρες-filter-wheel-g11"><i class="fa fa-check"></i>Κινητήρες filter wheel (G11)</a></li>
<li class="chapter" data-level="" data-path=""><a href="#τροφοδοσία-ισχύος"><i class="fa fa-check"></i>Τροφοδοσία ισχύος</a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#trackerinstallation"><i class="fa fa-check"></i>Εγκατάσταση του tracker.</a>
<ul>
<li class="chapter" data-level="" data-path=""><a href="#ρύθμιση-αζιμούθιου-άξονα."><i class="fa fa-check"></i>Ρύθμιση αζιμούθιου άξονα.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#ρύθμιση-ζενίθιου-άξονα."><i class="fa fa-check"></i>Ρύθμιση ζενίθιου άξονα.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#οριζοντίωση-του-ηλιοστάτη-leveling."><i class="fa fa-check"></i>Οριζοντίωση του ηλιοστάτη (leveling).</a></li>
</ul></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="" data-path=""><a href="#chp-1-quick-startup-on-radmon-computer."><i class="fa fa-check"></i>CHP-1 Quick startup (on ‘radmon’ computer).</a>
<ul>
<li class="chapter" data-level="" data-path=""><a href="#σύνδεση-του-tracker."><i class="fa fa-check"></i>Σύνδεση του tracker.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#reset-tracker."><i class="fa fa-check"></i>Reset tracker.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#εκκίνηση-του-προγράμματος-ελέγχου"><i class="fa fa-check"></i>Εκκίνηση του προγράμματος ελέγχου</a></li>
<li class="chapter" data-level="" data-path=""><a href="#διόπτευση-sighting"><i class="fa fa-check"></i>Διόπτευση (sighting)</a></li>
<li class="chapter" data-level="" data-path=""><a href="#σύνδεση-πολυμέτρου-protek-506"><i class="fa fa-check"></i>Σύνδεση πολυμέτρου ‘Protek 506’</a></li>
<li class="chapter" data-level="" data-path=""><a href="#εκκίνηση-προγράμματος-πολυμέτρου"><i class="fa fa-check"></i>Εκκίνηση προγράμματος πολυμέτρου</a></li>
<li class="chapter" data-level="" data-path=""><a href="#σε-περίπτωση-διακοπής-ρεύματος."><i class="fa fa-check"></i>Σε περίπτωση διακοπής ρεύματος.</a></li>
<li class="chapter" data-level="" data-path=""><a href="#scheduled-script-description"><i class="fa fa-check"></i>Scheduled script description</a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#tracker-microcontroler-source-code"><i class="fa fa-check"></i>Tracker microcontroler source code</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Εγχειρίδιο λειτουργίας ηλιοστάτη.</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="header">
<h1 class="title">Εγχειρίδιο λειτουργίας ηλιοστάτη.</h1>
<p class="author"><em>Thanasisn <a href="https://github.com/thanasisn">github.com/thanasisn</a></em></p>
<p class="date"><em>2025-02-19</em></p>
</div>
<div style="page-break-after: always;"></div>
<p> 

 </p>
<p>Αρχείο <a href="fff">pdf</a></p>
<p> 

 </p>
<blockquote>
<p>Η εργασία αυτή διανέμεται ως:<br />
<strong>Creative Commons - Αναφορά Δημιουργού -</strong><br />
<strong>Μη Εμπορική Χρήση - Παρόμοια Διανομή 4.0 Διεθνές.</strong><br />
<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">http://creativecommons.org/licenses/by-nc-sa/4.0/</a><br />
Στοιχειοθεσία έγινε με: <a href="https://bookdown.org/">bookdown</a>, <a href="https://www.r-project.org/">R</a>, <a href="http://rmarkdown.rstudio.com/">Rmarkdown</a>, <a href="https://pandoc.org/">Pandoc</a>, <a href="http://xetex.sourceforge.net/">XeTeX</a>.<br />
Build: 7e932587</p>
</blockquote>
<p> 

 </p>
<blockquote>
<p>Για διορθώσεις και προσθήκες επικοινωνήστε με <a href="mailto:natsisphysicist@gmail.com">ThanasisN</a>.</p>
</blockquote>
<p> 

 </p>
<p><strong><em>Σημείωση:</em> Ο πηγαίος κώδικας (source code) που παρατίθεται εδώ είναι ένα
παράδειγμα εφαρμογής κάποιων τεχνικών. Σε περίπτωση που θέλετε να τον
χρησιμοποιήσετε, προτείνουμε να δοκιμαστεί η καταλληλότητα του για την επιθυμητή
χρήση, πρώτα σε μη σημαντικές εφαρμογές (non-critical). Τα παραδείγματα κώδικα εδώ,
διαφέρουν από αυτά που χρησιμοποιούμε, λόγω της συνεχής εξέλιξης και βελτίωσης κατά
την χρήση τους.</strong></p>

<div style="page-break-after: always;"></div>
<p> <br />
 <br />
</p>
<div id="intro" class="section level1 unnumbered hasAnchor">
<h1>Εισαγωγή.<a href="#intro" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Το παρόν είναι ένας ανεπίσημος οδηγός για τη χρήση και τη λειτουργία του ηλιοστάτη
του ΕΦΑ. Συντάχτηκε από της διαθέσιμες πληροφορίες για τον ηλιοστάτη καθώς και από
την εμπειρία που αποκομίσαμε κατά τη χρήση του. Σκοπός μας είναι να βοηθήσει στην
περαιτέρω ανάπτυξη και χρήση του, γι’ αυτό ζητούμε την συνεισφορά σας στη βελτίωσή
του. Για διορθώσεις και προσθήκες μπορείτε να επικοινωνήσετε με τον
<a href="mailto:natsisphysicist@gmail.com">ThanasisN</a> (<a href="mailto:natsisphysicist@gmail.com" class="email">natsisphysicist@gmail.com</a>) ή το
Εργαστήριο Φυσικής της Ατμόσφαιρας του Α.Π.Θ.</p>
<p> <br />
 <br />
</p>

<div style="page-break-after: always;"></div>
</div>
<div id="tracker" class="section level1 hasAnchor">
<h1>Ο ηλιοστάτης του Εργαστηρίου Φυσικής της Ατμόσφαιρας.<a href="#tracker" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="trackerdescription" class="section level2 hasAnchor">
<h2>Περιγραφή tracker (ηλιοστάτη).<a href="#trackerdescription" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Η συσκευή αποτελείται από σώμα αλουμινίου, δύο άξονες κίνησης, δύο κινητήρες και
ηλεκτρονικό σύστημα ελέγχου. Οι άξονες έχουν ομόκεντρα γρανάζια τα οποία τίθενται σε
κίνηση από stepper motors μέσω κατάλληλου ιμάντα (Εικόνα <a href="#fig:trackerinside">1</a>).
Η επικοινωνία με το σύστημα ελέγχου γίνεται μέσω σειριακής θύρας (πραγματικής ή
εικονικής με τη χρήση μετατροπέα usb/serial).</p>
<p>Και οι δύο κάθετοι άξονες (αζιμούθιου και ζενίθ) έχουν τις ίδιες δυνατότητες και
χαρακτηριστικά μεταξύ τους, η λειτουργία τους είναι πανομοιότυπη και μπορούν να
κινηθούν ταυτόχρονα και ανεξάρτητα ο ένας από τον άλλο.</p>
<p>Οι κινητήρες του tracker μπορούν να κινηθούν με σταθερό βήμα <span class="math inline">\(0.6^\circ\)</span> ο καθένας.
Στο πρώτο μοντέλο του ηλιοστάτη, για τη μετάδοση της κίνησης, οι κινητήρες έχουν στο
γρανάζι τους 12 δόντια και κινούν μέσω ιμάντα τους άξονες, που έχουν από 70 δόντια ο
καθένας. Αυτό δίνει την δυνατότητα οι άξονες του ηλιοστάτη να κινούνται με διακριτό
βήμα <span class="math inline">\(0.6^\circ \cdot 12 / 70 \simeq 0.10286^\circ\)</span> για το παλιό μοντέλο. Τα
καινούρια μοντέλα του ηλιοστάτη, αντίστοιχα έχουν βήμα <span class="math inline">\({0.125}^\circ\)</span>.</p>
<p>Για την εκτέλεση μιας πλήρους περιστροφής του κάθε άξονα ο κινητήρας πρέπει να κάνει
<span class="math inline">\(360^\circ / (0.6^\circ \cdot 12 / 70) = 3500\)</span> βήματα στο παλιό μοντέλο και
<span class="math inline">\(360^\circ / {0.125}^\circ = 2880\)</span> βήματα στα καινούρια μοντέλα. Ενώ η μέγιστη
ταχύτατα περιστροφής των κινητήρων είναι περίπου μία περιστροφή ανά <span class="math inline">\(15\)</span>
δευτερόλεπτα.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:trackerinside"></span>
<img src="figure/20160615_125806.jpg" alt="Εσωτερικό του πρώτου μοντέλου tracker. Φαίνονται τα κύρια γρανάζια των αξόνων, ο κινητήρας του αζιμούθιου άξονα και το ηλεκτρονικό σύστημα ελέγχου, καθώς και το CHP 1." width="50%" />
<p class="caption">
Σχήμα 1: Εσωτερικό του πρώτου μοντέλου tracker. Φαίνονται τα κύρια γρανάζια των αξόνων, ο κινητήρας του αζιμούθιου άξονα και το ηλεκτρονικό σύστημα ελέγχου, καθώς και το CHP 1.
</p>
</div>
</div>
<div id="tracker_communication" class="section level2 hasAnchor">
<h2>Επικοινωνία με τον tracker.<a href="#tracker_communication" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Οι κινητήρες ελέγχονται από μικροελεγκτή (microcontroller), ο οποίος βρίσκεται μέσα
στο κύριο σώμα της συσκευής. Ο μικροελεγκτής είναι ήδη προγραμματισμένος να εκτελεί
άμεσα τις εντολές που λαμβάνει, μέσω της σειριακής επικοινωνίας.</p>
<p>Το λειτουργικό σύστημα του υπολογιστή αναγνωρίζει τη σειριακή σύνδεση με τον
microcontroller ως κάποια θύρα <code>COM#</code> στα Windows ή ως <code>/dev/ttyUSB#</code>, <code>/dev/ttyS#</code>
σε GNU/Linux. Οι εντολές μεταδίδονται στη συσκευή, γράφοντάς τις σε κάποια από αυτές
τις διευθύνσεις. Αντίστοιχα, οι απαντήσεις των εντολών διαβάζονται από την ίδια
διεύθυνση. Τυπικά, η επικοινωνία είναι πανομοιότυπη με την εγγραφή (write) και την
ανάγνωση (read) κειμένου (string) από αρχείο, με βήμα, μία γραμμή ανά εντολή. Κάθε
γραμμή τερματίζεται με τον χαρακτήρα <code>'\r'</code> (Carriage return, CR).</p>
<p>Η σειριακή επικοινωνία μπορεί να επιτευχθεί με άμεση σύνδεση του μικροελεγκτή σε
σειριακή θύρα του υπολογιστή. Είτε, μέσω μετατροπέα USB UART (adapter usb to serial)
σε θύρα USB του ηλεκτρονικού υπολογιστή (Σχήμα <a href="#fig:trackercon"><strong>??</strong></a>). Στην περίπτωσή
μας χρησιμοποιούμε τον μετατροπέα ‘FT232 USB-Serial (UART) IC’. Υπάρχει το ενδεχόμενο
κάποιοι μετατροπείς UART να μην επιτυγχάνουν σωστή επικοινωνία, λόγω των τεχνικών
τους χαρακτηριστικών.</p>
<div id="tracker_matlab" class="section level3 hasAnchor">
<h3>Επικοινωνία με τον Tracker σε περιβάλλον MatLab<a href="#tracker_matlab" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Σε αυτό το στάδιο περιγράφονται οι εντολές και οι παράμετροι που απαιτούνται
προκειμένου να επιτευχθεί επικοινωνία με τον Tracker σε περιβάλλον MatLab. Το MatLab
διαθέτει έτοιμες συναρτήσεις και εντολές για την επικοινωνία με ένα Serial Object, με
την προϋπόθεση να έχουμε εγκατεστημένο το Instrument Control Toolbox. Προτού
ανοίξουμε την σειριακή θύρα, πρέπει να δημιουργηθεί ένα Serial Object χρησιμοποιώντας
την εντολή <code>serial</code>, εισάγοντας τις αντίστοιχες ρυθμίσεις του Tracker. Στο MatLab
snippet που ακολουθεί, ορίζεται μια struct με όνομα ‘Tracker’, η οποία περιλαμβάνει
τόσο τις ρυθμίσεις της σειριακής επικοινωνίας (SerialConfiguration), όσο και αυτό
καθαυτό το Serial Object (SerialPort). Σημειώνεται ότι στον συγκεκριμένο κώδικα έχει
γίνει hard coding της Communication Port σε <code>COM4</code>, καθώς ξέρουμε ότι σε αυτήν την
θύρα είναι συνδεδεμένο το καλώδιο USB του Tracker. Για την αυτόματη εύρεση της COM
Port μπορεί να χρησιμοποιηθεί η εντολή <code>instrfindall</code> που εντοπίζει όλες τις ενεργές
συνδέσεις και επιστρέφει τις θύρες COM, στις οποίες βρίσκονται συνδεδεμένες συσκευές.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Set Tracker&#39;s Serial Port Configuration and create the Serial Object</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">COM</span>             <span class="op">=</span> <span class="ss">&#39;COM4&#39;</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">BaudRate</span>        <span class="op">=</span> <span class="fl">4800</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">DataBit</span>         <span class="op">=</span> <span class="fl">8</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">StopBit</span>         <span class="op">=</span> <span class="fl">1</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">Parity</span>          <span class="op">=</span> <span class="ss">&#39;none&#39;</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">Terminator</span>      <span class="op">=</span> <span class="ss">&#39;CR&#39;</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">Timeout</span>         <span class="op">=</span> <span class="fl">50</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">InputBufferSize</span> <span class="op">=</span> <span class="fl">5000</span><span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="va">Tracker</span>.<span class="va">SerialPort</span> <span class="op">=</span> <span class="va">serial</span>(<span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">COM</span><span class="op">,...</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="ss">&#39;BaudRate&#39;</span><span class="op">,</span><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">BaudRate</span><span class="op">,...</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="ss">&#39;DataBit&#39;</span><span class="op">,</span><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">DataBit</span><span class="op">,</span> <span class="op">...</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="ss">&#39;StopBit&#39;</span><span class="op">,</span><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">StopBit</span><span class="op">,</span> <span class="op">...</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="ss">&#39;Parity&#39;</span><span class="op">,</span><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">Parity</span><span class="op">,</span> <span class="op">...</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="ss">&#39;Terminator&#39;</span><span class="op">,</span><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">Terminator</span><span class="op">,</span> <span class="op">...</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="ss">&#39;Timeout&#39;</span><span class="op">,</span><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">Timeout</span><span class="op">,</span> <span class="op">...</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="ss">&#39;InputBufferSize&#39;</span><span class="op">,</span><span class="va">Tracker</span>.<span class="va">SerialConfiguration</span>.<span class="va">InputBufferSize</span>)<span class="op">;</span></span></code></pre></div>
<p>Η παράμετρος <code>InputBufferSize</code> επιτρέπει τον έλεγχο του αριθμού των bytes που μπορούν
να κρατηθούν στον buffer του μικροεπεξεργαστή και εφόσον δοθεί μια μεγάλη τιμή (όπως
στην περίπτωσή μας, 5000), μπορούμε να δίνουμε εντολές στον Tracker την μία πίσω από
την άλλη σε stack. Υπόψιν ότι ο μικροεπεξεργαστής σε αυτήν την περίπτωση θα
επιστρέψει ως πρώτη απάντηση το αποτέλεσμα της εντολής που ολοκληρώθηκε πρώτη και
στην συνέχεια με την ίδια λογική τις υπόλοιπες. Αφού δημιουργηθεί το Serial Object,
χρησιμοποιώντας τις εντολές <code>fopen</code> και <code>fclose</code> μπορούμε να ανοίξουμε και να
κλείσουμε αντίστοιχα την σειριακή θύρα. Με τις εντολές <code>fprintf</code> και <code>fscanf</code> δίνουμε
εντολή στον Tracker και λαμβάνουμε την απάντησή του αντίστοιχα σε μορφή ASCII.
Παρακάτω παρουσιάζεται ένα παράδειγμα για την εύρεση της θέσης (step) του Αζιμούθιου
άξονα</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Send the Command to the Tracker</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="va">fprintf</span>(<span class="va">Tracker</span>.<span class="va">SerialPort</span><span class="op">,</span> <span class="ss">&#39;AZ?&#39;</span>)<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Wait for the Tracker&#39;s microntroller to fill the buffer (Typically 0.5 sec)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="va">pause</span>(<span class="va">time_delay</span>)</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">% Get the Tracker&#39;s answer</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>[<span class="va">answer</span><span class="op">,</span> <span class="va">bytes</span><span class="op">,</span> <span class="va">msg_err</span>] <span class="op">=</span> <span class="va">fscanf</span>(<span class="va">Tracker</span>.<span class="va">SerialPort</span>)<span class="op">;</span></span></code></pre></div>
<p>Με τις παραπάνω εντολές, ο Tracker θα απαντήσει με την θέση σε βήματα του Αζιμούθιου
άξονα (πχ AZ:6000<cr>) στην μεταβλητή <code>answer</code>, τον αριθμό των bytes που στάλθηκαν (8
στην συγκεκριμένη περίπτωση) στην μεταβλητή <code>bytes</code> και τυχόν μηνύματα σφάλματος κατά
την σειριακή επικοινωνία στην μεταβλητή <code>msg_err</code>. Άλλες χρήσιμες εντολές και
παράμετροι για τον έλεγχο και την ορθή επικοινωνία με τον Tracker είναι η
<code>Tracker.SerialPort.BytesAvailable</code>, η οποία επιστρέφει τον αριθμό των bytes που
υπάρχουν διαθέσιμα στον buffer του microcontroller, η
<code>flushinput(Tracker.SerialPort)</code> και η <code>flushoutput(Tracker.SerialPort)</code> που
αδειάζουν τον Input και Output buffer αντίστοιχα.</p>
</div>
</div>
<div id="tracker_connection" class="section level2 hasAnchor">
<h2>Συνδεσμολογία<a href="#tracker_connection" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Έχει διαπιστωθεί εμπειρικά, ότι η σειρά της συνδεσμολογίας του ηλιοστάτη παίζει ρόλο
στην ορθή ενεργοποίηση των επιμέρους στοιχείων και την επιτυχή λειτουργία του
ηλιοστάτη. Για την επιτυχή επικοινωνία, προτείνουμε την αλληλουχία σύνδεσης (1-2-3-4)
ή (1-4-3-2) όπως φαίνεται στο Σχήμα<a href="#fig:trackercomm"><strong>??</strong></a>.</p>
<div style="page-break-after: always;"></div>
</div>
</div>
<div id="trackeroperation" class="section level1 hasAnchor">
<h1>Λειτουργία - Προγραμματισμός tracker.<a href="#trackeroperation" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="γενικές-πληροφορίες" class="section level2 hasAnchor">
<h2>Γενικές πληροφορίες<a href="#γενικές-πληροφορίες" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Κατά τη λειτουργία πρέπει να δοθεί προσοχή, διότι δεν υπάρχει μηχανικός περιορισμός
που να αποτρέπει την περιστροφή του άξονα κατά γωνίες μεγαλύτερες του πλήρη κύκλου.
Αυτό μπορεί να προκαλέσει πρόβλημα γιατί το καλώδιο του tracker αλλά και τον οργάνων
μπορεί να τυλιχθούν γύρω από τον άξονα και να καταστραφούν. Επίσης, σε περίπτωση που
η συσκευή δεν έχει τοποθετηθεί μόνιμα π.χ. σε τρίποδα, μπορεί η περιστροφή να
τραβήξει τα καλώδια και να ρίξει τη συσκευή.</p>
<p>Ο tracker όταν του δοθεί εντολή (reset), θα προσπαθήσει να μηδενίσει τον μετρητή
βήματος αφού μετακινηθεί σε μία γνωστή θέση. Αυτό γίνεται με την περιστροφή του
άξονα, μέχρι να φτάσει στη συγκεκριμένη θέση, την οποία αναγνωρίζει με μία φωτοδίοδο.
Προσοχή, σε περίπτωση που δεν πάρει σήμα από τη φωτοδίοδο, θα συνεχίσει να
περιστρέφεται ασταμάτητα. Αυτό μπορεί να συμβεί, αν το καπάκι είναι ανοιχτό σε
έντονο φως ή αν υπάρχει κάποιο πρόβλημα επικοινωνίας με τη φωτοδίοδο.</p>
<p>Ο tracker θα μηδενίσει τον κάθε άξονα στη θέση <code>'5000'</code>. Από εκεί και πέρα μπορεί να
κινηθεί και προς τις δύο κατευθύνσεις. Προσοχή, αν το βήμα γίνει αρνητικό από κάποια
εντολή ή αν γίνει μεγαλύτερο του <code>'9999'</code> ο tracker θα κολλήσει και θα συνεχίσει να
περιστρέφεται ασταμάτητα. Αυτό πρέπει να αποφευχθεί μέσω του προγραμματισμού του.
Μελλοντικά μπορεί να προστεθεί κάποιος μηχανικός ή ηλεκτρικός μηχανισμός περιορισμού.</p>
<p>Εάν το βήμα γίνει ακατάλληλο και ο tracker περιστρέφεται ασταμάτητα, μπορεί να
σταματήσει με την εντολή <code>'stop'</code>. Σε αυτήν την περίπτωση, αν ερωτηθεί για τη θέση
του επιστρέφει την τιμή <code>'9999'</code>.</p>
<p>Όταν ο ηλιοστάτης τροφοδοτείται και είναι σε λειτουργία, οι κινητήρες δεν θα
επιτρέψουν την ελεύθερη περιστροφή των αξόνων. Σε περίπτωση που χρειάζεται να
περιστραφούν ελεύθερα, πρέπει να διακοπεί η τροφοδοσία. <strong>Σημείωση</strong>: για το
πρώτο/παλιό μοντέλο του ηλιοστάτη (ορθογώνιο παραλληλόγραμμο καπάκι) η αντίσταση των
κινητήρων σε εξωτερική περιστροφή είναι πολύ μικρή, με αποτέλεσμα να είναι εύκολη η
τυχαία μετατόπισή του από εξωτερικούς παράγοντες. Σε αυτή την περίπτωση, είναι καλό
να γίνει επανεκκίνηση του προγράμματος ελέγχου του tracker, ώστε να ξαναβρεί τη θέση
του κάνοντας reset των αξόνων και στην συνέχεια, να ελεγχθεί αν η διόπτευση
(sighting) συνεχίζει να είναι σωστή.</p>
</div>
<div id="παράμετροι-επικοινωνίας-με-τον-microcontroller-του-tracker." class="section level2 hasAnchor">
<h2>Παράμετροι επικοινωνίας με τον microcontroller του tracker.<a href="#παράμετροι-επικοινωνίας-με-τον-microcontroller-του-tracker." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Στον Πίνακα <a href="#tab:trackerserial">1</a> περιγράφονται οι απαραίτητες παράμετροι για την
σύνδεση με τη σειριακή θύρα του tracker. Κατά την επικοινωνία, είναι χρήσιμο να
υπάρχει και κάποιο άνω όριο στον χρόνο που περιμένει ο υπολογιστής, πριν αποφασίσει
ότι η επικοινωνία δεν είναι εφικτή. Διαφορετικά, αν κάποιο μήνυμα περιμένει να
διαβαστεί από τη θύρα και αυτό δεν γίνει, μπορεί να παγώσει η επικοινωνία.</p>
<table>
<caption><span id="tab:trackerserial">Πίνακας 1: </span> Παράμετροι επικοινωνίας του tracker μέσω σειριακής θύρας RS-232.</caption>
<tbody>
<tr class="odd">
<td align="right"><strong>bits per second</strong></td>
<td align="left"><strong>4800</strong> (baudrate)</td>
</tr>
<tr class="even">
<td align="right"><strong>data bits</strong></td>
<td align="left"><strong>8</strong> (bytesize)</td>
</tr>
<tr class="odd">
<td align="right"><strong>parity</strong></td>
<td align="left"><strong>none</strong></td>
</tr>
<tr class="even">
<td align="right"><strong>stop bits</strong></td>
<td align="left"><strong>1</strong></td>
</tr>
<tr class="odd">
<td align="right"><strong>Flow control</strong></td>
<td align="left"><strong>none</strong></td>
</tr>
<tr class="even">
<td align="right"><strong>timeout</strong> (optional)</td>
<td align="left">90 sec</td>
</tr>
</tbody>
</table>
</div>
<div id="εντολές-tracker." class="section level2 hasAnchor">
<h2>Εντολές tracker.<a href="#εντολές-tracker." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="μορφή-εντολών-format." class="section level3 hasAnchor">
<h3>Μορφή εντολών (format).<a href="#μορφή-εντολών-format." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Η επικοινωνία με τον microcontroller του tracker γίνεται με εντολές που στέλνονται
μέσω σειριακής θύρας επικοινωνίας. Οι εντολές έχουν την μορφή κειμένου ‘string’ το
οποίο τερματίζεται με το σύμβολο <code>'cr'</code> ή <code>'\r'</code> (‘carriage return’ το τυπικό ‘enter’
των MS Windows).</p>
<p>Οι εντολές που έχουν ως όρισμα αριθμό βημάτων, πρέπει να δίνονται με διαμόρφωση
τεσσάρων ψηφίων. Όταν είναι αναγκαίο πρέπει να προπορεύονται από τα αντίστοιχα
μηδενικά (padded with zero). Για παράδειγμα 1000, 0999, 0099, 0001. Αυτό ισχύει για
την απόλυτη θέση (π.χ. <code>'AZ=0100'</code>) και για τη σχετική μετατόπιση (<code>'AZ+0100'</code>).</p>
<p>Αντίστοιχα, οι εντολές που αφορούν ταχύτητες έχουν την ίδια λογική μόνο που
χρησιμοποιούν δύο ψηφία.</p>
<p><strong>Προσοχή:</strong> Η απάντηση κάθε εντολής (ανάλογα και με τις ρυθμίσεις της σειριακής
επικοινωνίας) πρέπει να διαβαστεί από τη σειριακή σύνδεση γιατί διαφορετικά δεν θα
αδειάσει το buffer της σειριακής θύρας και μπορεί να παγώσει η επικοινωνία.</p>
</div>
<div id="μηδενισμός-του-βήματος-του-microcontroller." class="section level3 hasAnchor">
<h3>Μηδενισμός του βήματος του microcontroller.<a href="#μηδενισμός-του-βήματος-του-microcontroller." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Οι εντολές reset του Πίνακα <a href="#tab:trackercomstr">2</a> επιστρέφουν τους κινητήρες στην
αρχική τους (‘μηδενική’) θέση. Ο microcontroller αναλαμβάνει την κίνηση. Τους
περιστρέφει μέχρι την φωτοδίοδο και εκεί ρυθμίζει το εσωτερικό βήμα κάθε άξονα στη
τιμή <code>5000</code>. Μετά την εκτέλεση της εντολής ο tracker επιστρέφει τη διαφορά στη θέση
από τον προηγούμενο μηδενισμό. Αυτές οι εντολές συνήθως χρησιμοποιούνται κατά την
εκκίνηση της λειτουργίας ώστε να βεβαιωθούμε για την απόλυτη θέση του tracker, αφού
δεν υπάρχει άλλος μηχανισμός αναγνώρισης της θέσης. Προσοχή, για την σωστή
λειτουργία του μηδενισμού, οι παρακάτω εντολές πρέπει να δοθούν ξεχωριστά (όχι σε
stack) και να περιμένουμε τον μηδενισμό του κάθε άξονα με την αντίστοιχη απάντηση από
τον Tracker προτού δοθεί η επόμενη εντολή. Έπειτα από τον μηδενισμό του κάθε άξονα
πρέπει να δοθεί εντολή κίνησης του ίδιου άξονα πριν δοθεί εντολή μηδενισμού του
επόμενου άξονα, αλλιώς δημιουργείται πρόβλημα στην επικοινωνία και ο Tracker στην
συνέχεια δεν επιστρέφει την απάντηση OK όταν μεταβεί σε κάποια ζητούμενη θέση.
Υποθέτοντας ότι η θέση του αζιμούθιου, του ζενίθ και του φίλτρου της φωτοδιόδου είναι
5000, προτείνεται μετά από τον μηδενισμό του κάθε άξονα η κίνηση του ίδιου άξονα στην
θέση 5000 (δεν θα μετακινηθεί αφού ήδη βρίσκεται σε αυτήν την θέση, ωστόσο
αποφεύγεται το πρόβλημα της επικοινωνίας).</p>
<table>
<caption><span id="tab:trackercomstr">Πίνακας 2: </span> Εντολές μηδενισμού (reset) των αξόνων του tracker.</caption>
<colgroup>
<col width="20%" />
<col width="34%" />
<col width="44%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Εντολή</th>
<th align="center">Λειτουργία</th>
<th align="center">Απάντηση tracker</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><strong><code>DA</code></strong>&lt;cr&gt;</td>
<td align="center">reset azimuth motor</td>
<td align="center"><code>eA:####</code> (όταν βρει τη φωτοδίοδο)</td>
</tr>
<tr class="even">
<td align="center"><strong><code>DF</code></strong>&lt;cr&gt;</td>
<td align="center">reset filters (not used)</td>
<td align="center"><code>eF:####</code> (όταν βρει τη φωτοδίοδο)</td>
</tr>
<tr class="odd">
<td align="center"><strong><code>DZ</code></strong>&lt;cr&gt;</td>
<td align="center">reset zenith motor</td>
<td align="center"><code>eZ:####</code> (όταν βρει τη φωτοδίοδο)</td>
</tr>
</tbody>
</table>
</div>
<div id="κίνηση-των-αξόνων" class="section level3 hasAnchor">
<h3>Κίνηση των αξόνων<a href="#κίνηση-των-αξόνων" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Η εντολές για την κίνηση των αξόνων έχουν τη γενική μορφή: <code>xx@####&lt;cr&gt;</code> και
αποτελούνται από τρία τμήματα (εδώ τα συμβολίζουμε με ‘x’, ‘@’ και ‘#’). Η εξήγηση
των επιμέρους στοιχείων γίνεται στον Πίνακα<a href="#tab:trackercompart">3</a>
και <a href="#tab:trackercomoper">4</a>. Παραδείγματα έγκυρων εντολών βρίσκονται στον
Πίνακα<a href="#tab:trackercomexamp">6</a>. Το σύνολο των εντολών του ηλιοστάτη
παρατίθεται στον Πίνακα<a href="#tab:trackercommands">5</a>.</p>
<table>
<caption><span id="tab:trackercompart">Πίνακας 3: </span> Τα μέρη της εντολής του ηλιοστάτη.</caption>
<colgroup>
<col width="19%" />
<col width="80%" />
</colgroup>
<thead>
<tr class="header">
<th align="right">Παράμετρος</th>
<th align="left">Λειτουργία</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">xx</td>
<td align="left">Η παράμετρος στην οποία αναφέρεται</td>
</tr>
<tr class="even">
<td align="right">@</td>
<td align="left">Τελεστής της λειτουργίας που εκτελείται ( ?, =, +, - )</td>
</tr>
<tr class="odd">
<td align="right">####</td>
<td align="left">Αριθμητική τιμή της εντολής (##: για τις ταχύτητες)</td>
</tr>
<tr class="even">
<td align="right">&lt;cr&gt;</td>
<td align="left">Ο χαρακτήρας τερματισμού της εντολής</td>
</tr>
</tbody>
</table>
<table>
<caption><span id="tab:trackercomoper">Πίνακας 4: </span> Παράμετροι ελέγχου (operators/modifiers) των εντολών
του ηλιοστάτη.</caption>
<colgroup>
<col width="14%" />
<col width="62%" />
<col width="22%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Τελεστής (@)</th>
<th align="left">Λειτουργία</th>
<th align="left">Απάντηση</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">?</td>
<td align="left">Ζητά την τιμή της μεταβλητής από τον ηλιοστάτη, χωρίς ####</td>
<td align="left">xx:####&lt;cr&gt; ή xx:##&lt;cr&gt;</td>
</tr>
<tr class="even">
<td align="center">=</td>
<td align="left">Θέτει την τιμή της μεταβλητής,
## για παραμέτρους ταχύτητας και #### για
θέσης των αξόνων</td>
<td align="left">OK&lt;cr&gt;</td>
</tr>
<tr class="odd">
<td align="center">+</td>
<td align="left">Αυξάνει τη μεταβλητή κατά τη δοσμένη ποσότητα,
## για παραμέτρους ταχύτητας και #### για
θέσης των αξόνων</td>
<td align="left">OK&lt;cr&gt;</td>
</tr>
<tr class="even">
<td align="center">-</td>
<td align="left">Μειώνει τη μεταβλητή κατά τη δοσμένη ποσότητα
## για παραμέτρους ταχύτητας και #### για
θέσης των αξόνων</td>
<td align="left">OK&lt;cr&gt;</td>
</tr>
</tbody>
</table>
<table>
<caption><span id="tab:trackercommands">Πίνακας 5: </span> Εντολές ηλιοστάτη.</caption>
<colgroup>
<col width="27%" />
<col width="72%" />
</colgroup>
<thead>
<tr class="header">
<th align="right">Εντολές</th>
<th align="left">Μέγεθος</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">AZ@####&lt;cr&gt;</td>
<td align="left">Βήμα αζιμούθιου άξονα</td>
</tr>
<tr class="even">
<td align="right">ZE@####&lt;cr&gt;</td>
<td align="left">Βήμα ζενίθιου άξονα</td>
</tr>
<tr class="odd">
<td align="right">FR@####&lt;cr&gt;</td>
<td align="left">Βήμα τροχού φίλτρων</td>
</tr>
<tr class="even">
<td align="right">SA@##&lt;cr&gt;</td>
<td align="left">Ταχύτητα αζιμούθιου άξονα</td>
</tr>
<tr class="odd">
<td align="right">SZ@##&lt;cr&gt;</td>
<td align="left">Ταχύτητα ζενίθιου άξονα</td>
</tr>
<tr class="even">
<td align="right">SF@##&lt;cr&gt;</td>
<td align="left">Ταχύτητα τροχού φίλτρων</td>
</tr>
<tr class="odd">
<td align="right">OA@####&lt;cr&gt;</td>
<td align="left">Τροποποίηση αρχικής αζιμούθιας θέσης</td>
</tr>
<tr class="even">
<td align="right">OZ@####&lt;cr&gt;</td>
<td align="left">Τροποποίηση αρχικής ζενίθειας θέσης</td>
</tr>
<tr class="odd">
<td align="right">OF@####&lt;cr&gt;</td>
<td align="left">Τροποποίηση αρχικής θέσης φίλτρου</td>
</tr>
<tr class="even">
<td align="right">IA@####&lt;cr&gt;</td>
<td align="left">Τροποποίηση της θέσης της φωτοδιόδου του αζιμούθου άξονα</td>
</tr>
<tr class="odd">
<td align="right">IZ@####&lt;cr&gt;</td>
<td align="left">Τροποποίηση της θέσης της φωτοδιόδου του ζενίθιου άξονα</td>
</tr>
<tr class="even">
<td align="right">IF@####&lt;cr&gt;</td>
<td align="left">Τροποποίηση της θέσης της φωτοδιόδου του τροχού φίλτρων</td>
</tr>
<tr class="odd">
<td align="right">TA@####&lt;cr&gt;</td>
<td align="left">Τροποποίηση της ζητούμενης αζιμούθιας θέσης (μόνο ερώτηση)</td>
</tr>
<tr class="even">
<td align="right">TZ@####&lt;cr&gt;</td>
<td align="left">Τροποποίηση της ζητούμενης ζενίθειας θέσης (μόνο ερώτηση)</td>
</tr>
<tr class="odd">
<td align="right">TF@####&lt;cr&gt;</td>
<td align="left">Τροποποίηση της ζητούμενης θέσης του τροχού φίλτρων (μόνο ερώτηση)</td>
</tr>
<tr class="even">
<td align="right">GO XXXX,YYYY&lt;cr&gt;</td>
<td align="left">Μετακινεί ταυτόχρονα την αζιμούθια και ζενίθεια θέση σε XXXX και YYYY βήματα αντίστοιχα</td>
</tr>
<tr class="odd">
<td align="right">STOP&lt;cr&gt;</td>
<td align="left">Σταματά την κίνηση του ηλιοστάτη</td>
</tr>
<tr class="even">
<td align="right">DEBUG ON/OFF&lt;cr&gt;</td>
<td align="left">Ενεργοποιεί και απενεργοποιεί την κατάσταση αποσφαλμάτωσης (debuging). Στην περίπτωση του ON, ο ηλιοστάτης αποκρίνεται με την εντολή που του δόθηκε και την αντίστοιχη απάντηση</td>
</tr>
</tbody>
</table>
<p>Η εντολή <code>stop&lt;cr&gt;</code> σταματά την κίνηση των αξόνων. Λειτουργεί ακόμα και όταν ο
ηλιοστάτης έχει σφάλμα θέσης. Αυτό μπορεί να συμβεί, στην περίπτωση που το βήμα ενός
άξονα έχει φτάσει σε μη επιτρεπτή τιμή και ο τελευταίος περιστρέφεται ασταμάτητα. Με
την παραπάνω εντολή ο ηλιοστάτης σταματά την κίνηση και αποκρίνεται με την τιμή
<span class="math inline">\(9999\)</span> στο ερώτημα της θέσης.</p>
<table>
<caption><span id="tab:trackercomexamp">Πίνακας 6: </span> Παράδειγμα έγκυρης αλληλουχίας εντολών ηλιοστάτη.</caption>
<colgroup>
<col width="24%" />
<col width="75%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Εντολή</th>
<th align="left">Αποτέλεσμα</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">DA&lt;cr&gt;</td>
<td align="left">Μηδενισμός της θέσης του αζιμούθιου άξονα</td>
</tr>
<tr class="even">
<td align="center">DZ&lt;cr&gt;</td>
<td align="left">Μηδενισμός της θέσης του ζενίθιου άξονα</td>
</tr>
<tr class="odd">
<td align="center">AZ=6000&lt;cr&gt;</td>
<td align="left">Μετακίνηση αζιμούθιου άξονα στη θέση <span class="math inline">\(6000\)</span></td>
</tr>
<tr class="even">
<td align="center">ZE+0010&lt;cr&gt;</td>
<td align="left">Μετακίνηση άξονα ζενίθ <span class="math inline">\(10\)</span> βήματα στη θετική φορά</td>
</tr>
<tr class="odd">
<td align="center">AZ-0100&lt;cr&gt;</td>
<td align="left">Μετακίνηση άξονα αζιμούθιου <span class="math inline">\(100\)</span> βήματα στην αρνητική φορά</td>
</tr>
<tr class="even">
<td align="center">AZ?&lt;cr&gt;</td>
<td align="left">Ερώτημα θέσης, με απόκριση: AZ:5900&lt;cr&gt;</td>
</tr>
<tr class="odd">
<td align="center">SA=60&lt;cr&gt;</td>
<td align="left">Ταχύτητα του αζιμούθιου άξονα 60</td>
</tr>
<tr class="even">
<td align="center">?&lt;cr&gt;</td>
<td align="left">θέσεις των δύο αξόνων και του φίλτρου.<br />
Απαντήσεις: AZ:5010&lt;cr&gt;, ZE:5900&lt;cr&gt;, FR:####&lt;cr&gt;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="permissions-to-access-usb-serial-σε-gnulinux." class="section level2 hasAnchor">
<h2>Permissions to access USB serial σε GNU/Linux.<a href="#permissions-to-access-usb-serial-σε-gnulinux." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Με σύνδεση USB-to-serial, η συσκευή φαίνεται ως <code>/dev/ttyUSB0</code>. Ως συσκευή
συστήματος, συνήθως χρειάζεται να έχετε τα κατάλληλα δικαιώματα στο σύστημα για να
μπορείτε να την χρησιμοποιήσετε.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Add current user to dialout group (needs reboot)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> usermod <span class="at">-a</span> <span class="at">-G</span> dialout <span class="va">$USER</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Allow anyone to use the device (less secure, not permanent)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> chmod 666 /dev/ttyUSB0 </span></code></pre></div>
</div>
<div id="resetting-usbserial-interface-σε-gnulinux." class="section level2 hasAnchor">
<h2>Resetting USB/serial interface σε GNU/Linux.<a href="#resetting-usbserial-interface-σε-gnulinux." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Κάποιες ιδέες και προτάσεις για το πως μπορεί να γίνει επανασύνδεση της επικοινωνίας
χωρίς να αποσυνδεθεί η φυσική σύνδεση. Έχουν παραχθεί και τα αντίστοιχα ‘bash script’
που μπορούν να βρουν την κατάλληλη USB συσκευή και να εκτελέσουν τις παρακάτω
ενέργειες.</p>
<div id="αποσύνδεση-των-αντίστοιχων-modulefirmware-από-τον-kernel." class="section level3 hasAnchor">
<h3>Αποσύνδεση των αντίστοιχων module/firmware από τον kernel.<a href="#αποσύνδεση-των-αντίστοιχων-modulefirmware-από-τον-kernel." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Αυτές οι εντολές απενεργοποιούν και ενεργοποιούν τα κομμάτια του συστήματος που χειρίζονται τις σειριακές συσκευές και τις συσκευές USB.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">rmmod</span>  ftdi_sio</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ex">rmmod</span>  usbserial</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ex">modprobe</span> ftdi_sio</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ex">modprobe</span> usbserial</span></code></pre></div>
</div>
<div id="αποσύνδεση-της-συσκευής-από-το-σύστημα." class="section level3 hasAnchor">
<h3>Αποσύνδεση της συσκευής από το σύστημα.<a href="#αποσύνδεση-της-συσκευής-από-το-σύστημα." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Οι παρακάτω εντολές στέλνουν ένα σήμα σύνδεσης και αποσύνδεσης στην συσκευή USB.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> sh <span class="at">-c</span> <span class="st">&quot;echo 0 &gt; /sys/bus/usb/devices/1-1/authorized&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> sh <span class="at">-c</span> <span class="st">&quot;echo 1 &gt; /sys/bus/usb/devices/1-1/authorized&quot;</span></span></code></pre></div>
</div>
<div id="αποσύνδεση-του-mountpoint-από-το-σύστημα-untested." class="section level3 hasAnchor">
<h3>Αποσύνδεση του mountpoint από το σύστημα (untested).<a href="#αποσύνδεση-του-mountpoint-από-το-σύστημα-untested." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Αν και δεν έχουν δοκιμαστεί, οι εντολές αυτής της μορφής μπορούν να αποσυνδέσουν και να επανασυνδέσουν την διαδρομή αρχείου που αντιστοιχεί στην συσκευή και επομένως να ανανεώσουν την επικοινωνία.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">unbind</span> /dev/ttyUSB0</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">bind</span>   /dev/ttyUSB0</span></code></pre></div>
</div>
</div>
<div id="προγραμματισμός" class="section level2 hasAnchor">
<h2>Προγραμματισμός<a href="#προγραμματισμός" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Ο έλεγχος και ο αυτοματισμός της λειτουργίας του tracker, έχει γίνει στη γλώσσα προγραμματισμού Python.</p>
<div id="python" class="section level3 hasAnchor">
<h3>Python<a href="#python" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Η Python επιλέχτηκε ως μία σχετικά εύκολη γλώσσα προγραμματισμού με ευρεία σε χρήση
σε ποικιλία εφαρμογών. Είναι ελεύθερο λογισμικό και είναι διαθέσιμη για όλα τα
συστήματα και αρχιτεκτονικές υπολογιστών. Είναι δοκιμασμένη σε εξειδικευμένες, αλλά
και γενικές επιστημονικές εφαρμογές, με πλήθος αντίστοιχων εργαλείων/βιβλιοθηκών
(modules).</p>
<p>Είναι interpreting γλώσσα (τρέχει scripts χωρίς compiling) και αυτό δίνει αμεσότητα
στη χρήση της.</p>
<p>Τα βασικότερα module που χρησιμοποιήσαμε, από επιστημονικής άποψης, είναι αυτά για
τον υπολογισμό της θέσης του ήλιου στον ουρανό στη τοποθεσία μέτρησης. Αυτά είναι το
astropy και το pyephem (ephem). Στην τελική εφαρμογή, αναγκαστήκαμε να
χρησιμοποιήσουμε το pyephem λόγω κάποιο απροσδιόριστου προβλήματος λόγω λειτουργικού
συστήματος (windows).</p>
<p>Το astropy είναι πιο σύγχρονο και ενημερωμένο με υψηλή ακρίβεια και χρήση στην
αστρονομία. Το pyephem βασίζεται σε παλιότερο κώδικα (παραχώρηση από τον
προγραμματιστή του xephem) που όμως είναι δοκιμασμένος και σε άλλες εφαρμογές.</p>
<p>Ο κώδικας τεκμηριώνεται από αυτοματοποιημένο κείμενο που παράγετε με το pydoc ή το
doxygen από τα σχόλια που υπάρχουν μέσα σε αυτόν. Η python υποστηρίζει κάποιες
προδιαγραφές για τα σχόλια ώστε να τα χρησιμοποιεί ως τεκμηρίωση του προγράμματος.
Εδώ θα περιγραφούν πιο γενικές έννοιες της χρήσης και των λειτουργιών του, και όποια
σχόλια που είναι χρήσιμα για την γενικότερη κατανόηση του συστήματος. Προφανώς αυτό
το έγγραφο είναι συμπληρωματικό της ερευνητικής εργασίας για την οποία γράφτηκε.</p>
</div>
<div id="sun_tracker_main.py" class="section level3 hasAnchor">
<h3><code>sun_tracker_main.py</code><a href="#sun_tracker_main.py" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Το κύριο πρόγραμμα λειτουργίας του tracker. Αυτό το πρόγραμμα ελέγχει την λειτουργία του tracker και πρέπει να εκτελείτε συνεχώς για όσο χρειάζεται τα όργανα να ακολουθούν τον ήλιο. Στον πηγαίο κώδικα υπάρχουν λεπτομέρειες των λειτουργιών και της εφαρμογή τους.</p>
<div id="απαραίτητα-και-βοηθητικά-προγράμματα" class="section level4 hasAnchor">
<h4>Απαραίτητα και Βοηθητικά προγράμματα<a href="#απαραίτητα-και-βοηθητικά-προγράμματα" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><code>sun_vector_astropy.py</code></li>
<li><code>sun_vector_ephem.py</code></li>
<li><code>param_location.py</code></li>
<li><code>tracker_functions.py</code></li>
</ul>
</div>
<div id="επιγραμματικά-οι-λειτουργίες-του-προγράμματος." class="section level4 hasAnchor">
<h4>Επιγραμματικά οι λειτουργίες του προγράμματος.<a href="#επιγραμματικά-οι-λειτουργίες-του-προγράμματος." class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>Σειριακή επικοινωνία</li>
<li>Επικοινωνία tracker</li>
<li>Έλεγχος και επανασύνδεση επικοινωνίας</li>
<li>Ορατότητα του ήλιου</li>
<li>Θέση του ήλιου</li>
<li>Logging (και για το βοηθητικά προγράμματα)</li>
<li>Αποστολή κατάστασης tracker στο δίκτυο</li>
<li>Λήψη παραμέτρων sighting</li>
</ul>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:unnamed-chunk-7"></span>
<img src="figure/sun_tracker_main.png" alt="Λογικό διάγραμμα προγράμματος" width="90%" height="\textheight" />
<p class="caption">
Σχήμα 2: Λογικό διάγραμμα προγράμματος
</p>
</div>
</div>
</div>
<div id="sun_vector_astropy.py-και-sun_vector_ephem.py" class="section level3 hasAnchor">
<h3><code>sun_vector_astropy.py</code> και <code>sun_vector_ephem.py</code><a href="#sun_vector_astropy.py-και-sun_vector_ephem.py" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Απλά wrapper προγράμματα που περιέχουν από μία μέθοδο υπολογισμού της θέσης του ήλιου.</p>
<p>Ο σκοπός τους είναι να προετοιμάζουν τις κατάλληλες βιβλιοθήκες και να παρουσιάζουν
την ίδια λειτουργία ως προς την χρήση και τα αποτελέσματα στο <code>sun_tracker_main.py</code>.</p>
<ul>
<li>Για λειτουργικό σύστημα windows το astropy δεν λειτουργεί κανονικά.</li>
<li>Το ephem δεν λειτουργεί καλά κοντά στον ορίζοντα.</li>
<li>Υπάρχουν διαθέσιμες και άλλες μέθοδοι στη python για αυτός τους υπολογισμούς.</li>
<li>Υπάρχουν έτοιμα και κάποια binary γραμμένα σε C, Fortan και Basic που μπορούν να ενσωματωθούν σε κάποιο wrapper.</li>
</ul>
<p>Πιθανών να χρησιμοποιηθεί άλλη μέθοδος από το ephem που χρησιμοποιείται τώρα.</p>
</div>
<div id="param_location.py" class="section level3 hasAnchor">
<h3><code>param_location.py</code><a href="#param_location.py" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Περιέχει τις παραμέτρους τις τοποθεσίας, γεωγραφικό πλάτος, μήκος και υψόμετρο και τα
όρια του τοπικού ορίζοντα. Επίσης περιέχει κάποια κλιματολογία της τοποθεσίας η οποία
γίνεται διαθέσιμη στην μέθοδο υπολογισμού της θέσης του ήλιου.</p>
</div>
<div id="tracker_functions.py" class="section level3 hasAnchor">
<h3><code>tracker_functions.py</code><a href="#tracker_functions.py" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Περιέχει κάποιες βοηθητικές μεθόδους για το <code>sun_tracker_main.py</code> καθώς και κάποιες
μεθόδους για την λειτουργία του tracker. Για τον tracker έχει αποθηκευμένες κάποιες
τυπικές τιμές για την λειτουργία του. Δίνει την δυνατότητα αποθήκευσης, αλλαγής και
φόρτωσης των ρυμθμίσεών του. Και μπορεί να κάνει ελέγχους των τιμών των παραμέτρων
του και να προστατεύσει από εκτός ορίων τιμές.</p>
</div>
<div id="tracker_sighting_no_ui_tcp-port.py" class="section level3 hasAnchor">
<h3><code>tracker_sighting_no_ui_tcp-port.py</code><a href="#tracker_sighting_no_ui_tcp-port.py" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Αυτό το πρόγραμμα ελέγχει το offset (γωνία σε μοίρες) των δύο αξόνων του tracker.
Τρέχει σε τερματικό και στέλνει τις τιμές στο <code>sun_tracker_main.py</code> οι αλλαγές
εφαρμόζονται άμεσα στη θέση του tracker. Επίσης μπορεί να δώσει εντολή στο κύριο
πρόγραμμα να αποθηκεύσει, να μηδενίσει ή να διαβάσει τις τιμές από τον δίσκο. Αν οι
αλλαγές δεν σωθούν την επόμενη φορά που θα τρέξει το κύριο πρόγραμμα, θα διαβάσει τις
αποθηκευμένες τιμές από τον δίσκο. Οι αλλαγές παρόλα αυτά θα γραφτούν στο log κατά
την κανονική έξοδο του κύριου προγράμματος. Το βήμα αλλαγής της τιμής του offset
καθορίζεται στον κωδικά του προγράμματος και μπορεί να είναι οποιαδήποτε δεκαδική
τιμή.</p>
</div>
</div>
</div>
<div id="ηλεκτρικά---μηχανικά-χαρακτηριστικά." class="section level1 hasAnchor">
<h1>Ηλεκτρικά - Μηχανικά Χαρακτηριστικά.<a href="#ηλεκτρικά---μηχανικά-χαρακτηριστικά." class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="κινητήρες-tracker-57sh56-4am" class="section level2 hasAnchor">
<h2>Κινητήρες tracker (57SH56-4AM)<a href="#κινητήρες-tracker-57sh56-4am" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><img src="files/57SH56-4AM_400_STEP.png" width=".94\linewidth" style="display: block; margin: auto;" /></p>
</div>
<div id="κινητήρες-filter-wheel-g11" class="section level2 hasAnchor">
<h2>Κινητήρες filter wheel (G11)<a href="#κινητήρες-filter-wheel-g11" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><img src="files/FWmotor.png" width="1\linewidth" style="display: block; margin: auto;" /></p>
<p><img src="files/FWmotor_wiring.png" width="1\linewidth" style="display: block; margin: auto;" /></p>
</div>
<div id="τροφοδοσία-ισχύος" class="section level2 hasAnchor">
<h2>Τροφοδοσία ισχύος<a href="#τροφοδοσία-ισχύος" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Το τροφοδοτικό του tracker παρέχει συνεχή διαφορά δυναμικού <span class="math inline">\(19-20\ V\)</span>. Για την ώρα
δεν γνωρίζουμε την δυνατότητα σε ισχύ της συσκευής ούτε και το μέγιστο ηλεκτρικό
ρεύμα που μπορεί να χρησιμοποιήσει. Στην ηλεκτρονική πλακέτα, αναμένουμε περίπου
<span class="math inline">\(18\ V\)</span> μετά από την πτώση τάσης στο καλώδιο τροφοδοσίας.</p>
<div style="page-break-after: always;"></div>
</div>
</div>
<div id="trackerinstallation" class="section level1 hasAnchor">
<h1>Εγκατάσταση του tracker.<a href="#trackerinstallation" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Είναι αναγκαίο το επίπεδο τις συσκευής να είναι απολύτως οριζόντιο, αλλά και να
διατηρείται κατά τη λειτουργία του συστήματος tracker-οργάνου. Γι’ αυτό η βάση,
πρέπει να είναι αρκετά σταθερή αλλά και να έχει τη δυνατότητα λεπτομερούς ρύθμισης
του επιπέδου. Στη συνέχεια θα περιγράψουμε την ρύθμιση του οργάνου για την
παρακολούθηση της πορείας του Ήλιου.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:trackercompass"></span>
<img src="figure/compass.png" alt="Δορυφορική φωτογραφία της τοποθεσίας μετρήσεων (κόκκινο). Έχουν σχεδιαστεί οι κατευθύνσεις που αντιστοιχούν στα σημεία του ορίζοντα (μπλε), το αζιμούθιο του ήλιου κατά την ανατολή και τη δύση στις 21 Ιουλίου (κίτρινο) και αντίστοιχα στις 21 Δεκεμβρίου (πράσινο). Όλες οι γωνίες είναι μετρημένες με αρχή την κατεύθυνση του Βορρά." width="100%" />
<p class="caption">
Σχήμα 3: Δορυφορική φωτογραφία της τοποθεσίας μετρήσεων (κόκκινο). Έχουν σχεδιαστεί οι κατευθύνσεις που αντιστοιχούν στα σημεία του ορίζοντα (μπλε), το αζιμούθιο του ήλιου κατά την ανατολή και τη δύση στις 21 Ιουλίου (κίτρινο) και αντίστοιχα στις 21 Δεκεμβρίου (πράσινο). Όλες οι γωνίες είναι μετρημένες με αρχή την κατεύθυνση του Βορρά.
</p>
</div>
<!-- convert -density 300 compass.pdf -shave 204x0 -quality 100 ccc.pdf -->
<!-- convert -density 300 -quality 100 ccc.pdf compass.png -->
<div id="ρύθμιση-αζιμούθιου-άξονα." class="section level2 hasAnchor">
<h2>Ρύθμιση αζιμούθιου άξονα.<a href="#ρύθμιση-αζιμούθιου-άξονα." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Πρώτο βήμα, είναι η ευθυγράμμιση του μηδέν του αζιμούθιου της συσκευής με τον Βορρά.
Αυτό μπορεί να γίνει με άμεση ευθυγράμμιση, αν η θέση του Βορρά είναι γνωστή (Εικόνα
<span class="math inline">\(\ref{fig:trackercompass}\)</span>). Εναλλακτικά, μπορεί να γίνει όταν η συσκευή είναι ενεργή
και ακολουθεί τον ήλιο. Τότε, η διόπτευση του ήλιου μπορεί να χρησιμοποιηθεί για να
ευθυγραμμίσει το αζιμούθιο με τον Βορρά. Και στις δύο περιπτώσεις η συσκευή πρέπει να
τοποθετηθεί στη βάση της και να μπορεί να περιστραφεί πριν σταθεροποιηθεί στην τελική
της θέση. Περαιτέρω, βελτίωση της θέσης του μηδενός του αζιμουθιακού άξονα, μπορεί να
γίνει προγραμματιστικά, με τις μεταβλητές του offset στο πρόγραμμα που τις ελέγχει.</p>
</div>
<div id="ρύθμιση-ζενίθιου-άξονα." class="section level2 hasAnchor">
<h2>Ρύθμιση ζενίθιου άξονα.<a href="#ρύθμιση-ζενίθιου-άξονα." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Για τον ζενίθιο άξονα, δεν θα χρειαστεί κάποια διαδικασία από τη στιγμή που η συσκευή
είναι οριζοντιωμένη. Αν γνωρίζουμε τη θέση αναφοράς όπου μηδενίζει το όργανο,
μπορούμε να υπολογίσουμε την θέση που ο άξονας θα βρίσκεται στο ζενίθ ή κάθετα σε
αυτό (ανάλογα με τη βάση πρόσδεσης του οργάνου). Έτσι, μπορούμε να θέσουμε αυτήν την
παράμετρο στο πρόγραμμα που ελέγχει τη συσκευή. Μία άλλη προσέγγιση, για να βρούμε το
offset της στόχευσης, είναι η προσάρτηση του οργάνου να γίνει ενώ ο tracker ακολουθεί
τον ήλιο, ώστε να ευθυγραμμιστεί με αυτόν. Αυτό προϋποθέτει ότι η στερέωση του
οργάνου μπορεί να γίνει σε οποιαδήποτε γωνία σε σχέση με τον άξονα.</p>
</div>
<div id="οριζοντίωση-του-ηλιοστάτη-leveling." class="section level2 hasAnchor">
<h2>Οριζοντίωση του ηλιοστάτη (leveling).<a href="#οριζοντίωση-του-ηλιοστάτη-leveling." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Τέλος, έχουμε την καθετοποίηση του οργάνου, ώστε ο άξονας του αζιμούθιου να είναι
κατακόρυφος στη Γη. Μετά την τοποθέτηση των οργάνων μέτρησης, αλλά και περιοδικά, η
καθετότητα του άξονα πρέπει να ελέγχεται. Καθώς, αποκλίσεις μπορούν να προκαλέσουν
εσφαλμένες μετρήσεις κατά τη διάρκεια της ημέρας. Η ανάγκη αυτή, μπορεί να φανεί όταν
μετά από διόπτευση (sighting) του Ήλιου, ο tracker χάνει γρήγορα την ευθυγράμμισή
του.</p>
<p>Ξεκινάμε με τον tracker χωρίς τροφοδοσία, ώστε να μπορεί να περιστραφεί ελεύθερα γύρω
από τον κατακόρυφο άξονα. Για τον έλεγχο της στάθμης χρησιμοποιούμε αλφάδι φυσαλίδας
(αεροστάθμη) με δυνατότης ανεξάρτητης ρύθμισης του επιπέδου του σε σχέση με το
όργανο, όπως φαίνεται στην Εικόνα <a href="#fig:trackerleveling">4</a>.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:trackerleveling"></span>
<img src="../../Aerosols/Photos/EL/20160307_Tracker_CHP1_CCD/20160307_124618.JPG" alt="Οριζοντίωση του tracker. Φαίνεται ο tracker εγκατεστημένος σε ρυθμιζόμενη βάση (τρίποδο) και η αεροστάθμη (αλφάδι) με την οποία ελέγχεται η οριζοντίωση." width="80%" />
<p class="caption">
Σχήμα 4: Οριζοντίωση του tracker. Φαίνεται ο tracker εγκατεστημένος σε ρυθμιζόμενη βάση (τρίποδο) και η αεροστάθμη (αλφάδι) με την οποία ελέγχεται η οριζοντίωση.
</p>
</div>
<p>Θα ρυθμίσουμε κάθε σημείο ελευθερίας του επιπέδου (εδώ, κάθε πόδι της βάσης)
διαδοχικά, μέχρι το επίπεδο του οργάνου να συμφωνεί με το επίπεδο αναφοράς της
στάθμης. Σε όλη τη διαδικασία δεν πρέπει να αλλάξουμε τη θέση του οργάνου της στάθμης
πάνω στο όργανο.</p>
<p>Η διαδικασία για κάθε πόδι έχει ως εξής: Φέρνουμε τον άξονα της φυσαλίδας παράλληλο
με την διεύθυνση του ποδιού. Αλλάζουμε το ύψος του και ρυθμίζουμε ξανά το όργανο
στάθμης, προσπαθώντας να μοιράσουμε την μεταβολή ισόποσα μεταξύ των δύο.
Περιστρέφουμε τον tracker κατά <span class="math inline">\(180^\circ\)</span> και επαναλαμβάνουμε τη ρύθμιση και των
δύο.</p>
<p>Το παραπάνω βήμα, το επαναλάβουμε μέχρι η στάθμη να είναι ικανοποιητικά επίπεδη. Με
τον ίδιο τρόπο ρυθμίζουμε διαδοχικά και τα υπόλοιπα πόδια. Πιθανότατα, θα χρειαστεί
παραπάνω από ένας κύκλος ρυθμίσεων και για το κάθε πόδι, αλλά και για τα τρία σε
αλληλουχία. Το πλήθος τους, θα εξαρτηθεί από την ευαισθησία του μηχανισμού ρύθμισης,
την ικανότητα του χειριστή αλλά και το επιθυμητό επίπεδο ακρίβειας.</p>
<p>Επαναλαμβάνουμε ότι είναι σημαντική η περιστροφή tracker μαζί με όργανο στάθμης κατά
<span class="math inline">\(180^\circ\)</span>, διότι πρέπει να ληφθεί υπόψη ότι το κάλυμμα του οργάνου δεν είναι κατ’
ανάγκη παράλληλο με τη βάση του (π.χ. μπορεί να έχει παραμορφωθεί).</p>

<div style="page-break-after: always;"></div>
</div>
</div>



<div id="chp-1-quick-startup-on-radmon-computer." class="section level1 hasAnchor">
<h1>CHP-1 Quick startup (on ‘radmon’ computer).<a href="#chp-1-quick-startup-on-radmon-computer." class="anchor-section" aria-label="Anchor link to header"></a></h1>
<!-- \vspace{-1.5\baselineskip}  -->
<div id="σύνδεση-του-tracker." class="section level2 unnumbered hasAnchor">
<h2>Σύνδεση του tracker.<a href="#σύνδεση-του-tracker." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Στο τροφοδοτικό του tracker συνδέονται τρία καλώδια. Συνήθως, η σύνδεση πετυχαίνει
αν τα καλώδια συνδεθούν με τη σειρά από δεξιά προς τα αριστερά ή το αντίθετο. Η
εκτέλεση του προγράμματος θα δείξει αν η επικοινωνία μπορεί να γίνει σωστά.</p>
</div>
<div id="reset-tracker." class="section level2 unnumbered hasAnchor">
<h2>Reset tracker.<a href="#reset-tracker." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Όταν ο tracker τροφοδοτείται τα ηλεκτρονικά του είναι ενεργά, μερικές φορές, αυτό
αποτρέπει την επανασύνδεση. Για να λυθεί αυτό ή πρέπει να μείνει για μερικά λεπτά
χωρίς τροφοδοσία, ή να βραχυκυκλωθούν οι επαφές που τροφοδοτούν την ηλεκτρονική
πλακέτα του tracker. <strong>ΠΡΟΣΟΧΗ: εφαρμόστε λογική και αποσυνδέστε πρώτα την
τροφοδοσία ρεύματος</strong>. Αν το περίβλημα του tracker είναι ανοικτό, οι επαφές είναι
προσβάσιμες. Εναλλακτικά, μπορούν να βραχυκυκλωθούν οι επαφές του καλωδίου με κάποιο
μεταλλικό αντικείμενο και μόνο από τη μεριά του καλωδίου που συνδέεται στο
τροφοδοτικό, ώστε να είστε σίγουροι για τη κατάσταση τροφοδοσίας.</p>
</div>
<div id="εκκίνηση-του-προγράμματος-ελέγχου" class="section level2 unnumbered hasAnchor">
<h2>Εκκίνηση του προγράμματος ελέγχου<a href="#εκκίνηση-του-προγράμματος-ελέγχου" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Το πρόγραμμα ελέγχου του tracker (<strong>sun_tracker_main.py</strong>) μπορεί να ξεκινήσει:</p>
<ul>
<li>Χειροκίνητα (link στην επιφάνεια εργασίας)</li>
<li>Μέσω του ‘Scheduled Tasks’ (properties -&gt; run)</li>
<li>Εκτέλεση από command line (cmd.exe):</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">c:\&gt;</span><span class="op">&lt;</span>python path<span class="op">&gt;</span><span class="dt">\p</span>ython.exe <span class="op">&lt;</span>script path<span class="op">&gt;</span><span class="dt">\s</span>un_tracker_main.py</span></code></pre></div>
</div>
<div id="διόπτευση-sighting" class="section level2 unnumbered hasAnchor">
<h2>Διόπτευση (sighting)<a href="#διόπτευση-sighting" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Το sighting του Ήλιου μπορεί να γίνει με το πρόγραμμα
<strong>tracker_sighting_no_ui_tcp-port.py</strong> (υπάρχει link στην επιφάνεια εργασίας). Το
πρόγραμμα εμφανίζει τις δυνατές επιλογές στην οθόνη και περιμένει είσοδο από το
πληκτρολόγιο. Οι ρυθμίσεις επιδρούν άμεσα στη θέση του tracker (το πρόγραμμα
<strong>sun_tracker_main.py</strong> πρέπει να εκτελείται και ο tracker πρέπει να έχει αρχίσει την
κανονική λειτουργία). Ανάδραση (feedback) των ρυθμίσεων μπορούμε να έχουμε
παρακολουθώντας το terminal που τρέχει το <strong>sun_tracker_main.py</strong>. <strong>ΠΡΟΣΟΧΗ.</strong> Οι
ρυθμίσεις πρέπει να σωθούν (<code>'s'</code>) για να αποθηκευτούν στον δίσκο και να διατηρηθούν
στην επόμενη εκτέλεση (ημέρα).</p>
<p><strong>Σημείωση:</strong> Είναι βολικό το sighting να γίνεται με κάποιο smart phone μέσω remote
desktop (‘rdp’). Έτσι, μπορεί να υπάρχει άμεση επίβλεψη της κίνησης του tracker και
των διορθώσεων και διευκολύνεται ο συγχρονισμός της κίνησης του tracker με τη θέση
του ήλιου.</p>
</div>
<div id="σύνδεση-πολυμέτρου-protek-506" class="section level2 unnumbered hasAnchor">
<h2>Σύνδεση πολυμέτρου ‘Protek 506’<a href="#σύνδεση-πολυμέτρου-protek-506" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Το πολύμετρο μετράει την αντίσταση του pt100 ή του θερμίστορ (χρωματισμός καλωδίων
στο manual του CHP) και η μέτρηση διαβάζεται μέσω ‘RS-232’. Στο πολύμετρο πρέπει να
είναι ενεργές οι επιλογές ‘<em>KEEP ON</em>’ και ‘<em>RS232</em>’. Αυτό γίνεται με τα πλήκτρα
‘menu’ και ‘enter’ για κάθε μία από τις ρυθμίσεις.</p>
</div>
<div id="εκκίνηση-προγράμματος-πολυμέτρου" class="section level2 unnumbered hasAnchor">
<h2>Εκκίνηση προγράμματος πολυμέτρου<a href="#εκκίνηση-προγράμματος-πολυμέτρου" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Το πρόγραμμα (<strong>protek506_measurments.py</strong>) παίρνει μετρήσεις της αντίστασης -
θερμοκρασίας του CHP1 και μπορεί να εκτελεστεί με όμοιο τρόπο με το πρόγραμμα του
tracker. Καθώς το πρόγραμμα παίρνει μετρήσεις, στη οθόνη του πολυμέτρου πρέπει να
αναβοσβήνουν εναλλάξ οι ενδείξεις ‘<em>RX</em>’ και ‘<em>TX</em>’. Αν αυτό δεν γίνεται τότε η
επικοινωνία έχει κολλήσει και το πολύμετρο πρέπει να κλείσει, να ξανανοίξει και να
ρυθμιστεί (όπως παραπάνω).</p>
</div>
<div id="σε-περίπτωση-διακοπής-ρεύματος." class="section level2 unnumbered hasAnchor">
<h2>Σε περίπτωση διακοπής ρεύματος.<a href="#σε-περίπτωση-διακοπής-ρεύματος." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Έχει παρατηρηθεί ότι ο tracker μπορεί να ξεκινήσει κανονικά όταν επανέλθει η
τροφοδοσία και ξεκινήσει ο υπολογιστής. Αλλά αυτό δεν γίνεται πάντα.</p>
</div>
<div id="scheduled-script-description" class="section level2 unnumbered hasAnchor">
<h2>Scheduled script description<a href="#scheduled-script-description" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Τα παρακάτω script εκτελούνται συνεχώς από το ‘Task Scheduler’ και σχετίζονται με τη
καθημερινή λειτουργία του tracker και του CPH1, και είναι:</p>
<ul>
<li><strong>sun_tracker_main.py</strong> (απαραίτητο, ελέγχει την κίνηση του tracker)</li>
<li><strong>protek506_measurments.py</strong> (σημαντικό, μετράει την θερμοκρασία του CPH1)</li>
<li><strong>data_pub_win.py</strong> (βοηθητικό, εκπέμπει δεδομένα λειτουργίας του tracker)</li>
</ul>
<p><strong>Σημείωση:</strong> Σε περίπτωση που κάποιο από αυτά ήδη εκτελείται δεν θα ξανατρέξει,
διότι υπάρχει εσωτερικός έλεγχος στον κώδικα του κάθε προγράμματος.</p>
<p><strong>Σημείωση:</strong> Πρέπει να είναι είναι ενεργή η επιλογή: <code>"Disable error reporting"</code>
ώστε να μην κολλάει ο tracker περιμένοντας τον διάλογο του “Error reporting” όταν
crashάρει. Πιθανόν και η επιλογή <code>"But notify me when critical error occurs"</code> (υπό
δοκιμή για την ώρα). Για <em>Windows XP: Control Panel &gt; System &gt; Advanced &gt; Error
reporting</em>.</p>
</div>
</div>
<div id="tracker-microcontroler-source-code" class="section level1 hasAnchor">
<h1>Tracker microcontroler source code<a href="#tracker-microcontroler-source-code" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<pre><code>#include    &lt;htc.h&gt;
__CONFIG(FOSC_INTOSC&amp;WDTE_ON&amp;PWRTE_OFF&amp;MCLRE_OFF&amp;CP_ON&amp;CPD_ON&amp;BOREN_ON&amp;CLKOUTEN_OFF&amp;IESO_OFF&amp;FCMEN_OFF);
__CONFIG(WRT_ALL&amp;PLLEN_OFF&amp;STVREN_ON&amp;LVP_OFF);//&amp;BORV_25

#pragma warning disable 340

#define _XTAL_FREQ 16000000

#define BIT0        0b00000001
#define BIT1        0b00000010
#define BIT2        0b00000100 
#define BIT3        0b00001000
#define BIT4        0b00010000
#define BIT5        0b00100000
#define BIT6        0b01000000
#define BIT7        0b10000000
#define BIT0_       0b11111110
#define BIT1_       0b11111101
#define BIT2_       0b11111011
#define BIT3_       0b11110111
#define BIT4_       0b11101111
#define BIT5_       0b11011111
#define BIT6_       0b10111111
#define BIT7_       0b01111111


#define PIN_A_A1_L              LATE1
#define PIN_A_A1_H              LATE2
#define PIN_A_A2_L              LATE0
#define PIN_A_A2_H              LATA5
#define PIN_A_B1_L              LATA1
#define PIN_A_B1_H              LATA4
#define PIN_A_B2_L              LATA2
#define PIN_A_B2_H              LATA3


#define PIN_Z_A1_L              LATD0
#define PIN_Z_A1_H              LATD1
#define PIN_Z_A2_L              LATC3
#define PIN_Z_A2_H              LATC2
#define PIN_Z_B1_L              LATC0
#define PIN_Z_B1_H              LATC1
#define PIN_Z_B2_L              LATA6
#define PIN_Z_B2_H              LATA7

#define PIN_F_A1_L              LATD3
#define PIN_F_A1_H              LATD2
#define PIN_F_A2_L              LATC4
#define PIN_F_A2_H              LATC5
#define PIN_F_B1_L              LATD5
#define PIN_F_B1_H              LATD4
#define PIN_F_B2_L              LATD6
#define PIN_F_B2_H              LATD7


#define PIN_A_OPTO              RB2
#define PIN_Z_OPTO              RB3
#define PIN_F_OPTO              RB4



#define OA_Mem                  10
#define OZ_Mem                  20
#define OF_Mem                  30

#define SpeedA_Mem              40
#define SpeedZ_Mem              41
#define SpeedF_Mem              42

#define DA_Mem                  50
#define DZ_Mem                  60
#define DF_Mem                  70

#define AZ_Mem                  90



const unsigned char StepMotorMatrix[5]={  // A1L A1H A2L A2H B1L B1H B2L B2H  
0b00000000,// OFF 
0b10010000,//
0b00001001,//
0b01100000,//
0b00000110 //
};



unsigned char TX_out;
unsigned char RX_in;


unsigned char Mem_Data;
unsigned char Mem_Address;

unsigned int  TxFSM;
unsigned char TxChar;
unsigned int  TxStringCounter;

unsigned int  RxFSM;
unsigned char RxChar;
unsigned int  RxCounter;

/*
unsigned int  ADC_tempResult;
unsigned char Counter_ADC_Sum;
unsigned int  I1_Sum;
unsigned int  I2_Sum;
unsigned int  I3_Sum;
unsigned int  I4_Sum;
unsigned int  I5_Sum;
unsigned int  I1_Sum_temp;
unsigned int  I2_Sum_temp;
unsigned int  I3_Sum_temp;
unsigned int  I4_Sum_temp;
unsigned int  I5_Sum_temp;
*/


unsigned char Counter100usec;
unsigned char Counter1msec;
unsigned char Counter10msec;
unsigned char Counter100msec;
unsigned char Counter1sec=50;

unsigned int  ITD_Input;
unsigned char ITD_Output[5];

unsigned char ADCFSM=0;



unsigned int  Timer_Init=20;


unsigned char MainFSM=0;
unsigned int  MainTimer=0;


unsigned char ReceivedByte;
unsigned char ReceiveFIFO[20];
unsigned char ReceiveValid;
unsigned char ReceiveCommand;
unsigned char ReceivedBytesCounter=0;

unsigned char TX_Mirror_Matrix[10];
unsigned int  TX_Mirror_Counter=0;

unsigned char TX_Matrix[81];
unsigned int  TX_Counter;
unsigned int  TX_Counter_Max;
unsigned char SendFlag;

unsigned char TXFSM;

unsigned char StepMotorStateA=0;
unsigned char StepMotorStateZ=0;
unsigned char StepMotorStateF=0;

unsigned int  AZ=5000;
unsigned int  ZE=5000;
unsigned int  FR=5000;

unsigned int  OA=0;
unsigned int  OZ=0;
unsigned int  OF=0;

unsigned int  Init_DA=0;
unsigned int  Init_DZ=0;
unsigned int  Init_DF=0;

unsigned int  AZtarget=100;
unsigned int  ZEtarget=100;
unsigned int  FRtarget=100;

unsigned int  AZterminal=100;
unsigned int  ZEterminal=100;
unsigned int  FRterminal=100;


unsigned int  AZtarget_temp=100;
unsigned int  ZEtarget_temp=100;
unsigned int  FRtarget_temp=100;

unsigned char SpeedA=10;
unsigned char SpeedZ=10;
unsigned char SpeedF=10;

unsigned char SpeedAnow=1;
unsigned char SpeedZnow=1;
unsigned char SpeedFnow=1;

unsigned char SpeedAtarget=1;
unsigned char SpeedZtarget=1;
unsigned char SpeedFtarget=1;

unsigned char SpeedAcalc=0;
unsigned char SpeedZcalc=0;
unsigned char SpeedFcalc=0;

unsigned int  Counter_Speed_A=0;
unsigned int  Counter_Speed_Z=0;
unsigned int  Counter_Speed_F=0;

unsigned int  ReceiveNumber=0;

unsigned int  AZ_Memory=0;

unsigned int  FSM=0;

unsigned int  FSM_A=0;
unsigned int  FSM_Z=0;
unsigned int  FSM_F=0;

unsigned int  Timer_FSM_A=0;
unsigned int  Timer_FSM_Z=0;
unsigned int  Timer_FSM_F=0;



unsigned int  A_OPTO_Shift=0b0101010101010101;
unsigned int  Z_OPTO_Shift=0b0101010101010101;
unsigned int  F_OPTO_Shift=0b0101010101010101;


unsigned int  tempint;
unsigned char tempB;




bit FLAG1msec=0;

bit Moving=0;
bit OKpending=0;

bit AZsync=0;
bit ZEsync=0;
bit FRsync=0;

bit SendAll=0;

bit SendAZ=0;
bit SendZE=0;
bit SendFR=0;

bit SendOA=0;
bit SendOZ=0;
bit SendOF=0;

bit SendDA=0;
bit SendDZ=0;
bit SendDF=0;

bit SendSA=0;
bit SendSZ=0;
bit SendSF=0;

bit SendTA=0;
bit SendTZ=0;
bit SendTF=0;

bit SendOK=0;
bit SendLF=0;

bit SendDebugOff=0;
bit SendDebugOn=0;

bit Debug=0;

bit GoToTargetA=0;
bit GoToTargetZ=0;
bit GoToTargetF=0;
bit GoToTargetAll=0;

bit TargetReachedA=0;
bit TargetReachedZ=0;
bit TargetReachedF=0;
bit TargetReachedAll=0;

bit GoToTerminalA=0;
bit GoToTerminalZ=0;
bit GoToTerminalF=0;
bit GoToTerminalAll=0;

bit TerminalReachedA=0;
bit TerminalReachedZ=0;
bit TerminalReachedF=0;
bit TerminalReachedAll=0;

bit StopA=0;
bit StopZ=0;
bit StopF=0;
bit StopAll=0;

bit CounterApulse=0;
bit CounterZpulse=0;
bit CounterFpulse=0;

bit PositionValid_A=0;
bit PositionValid_Z=0;
bit PositionValid_F=0;

bit A_OPTO=0;
bit Z_OPTO=0;
bit F_OPTO=0;

void SPI(void);
void MemRead(void);
void MemWrite(void);
void ReadParameters(void);
void WriteParameters(void);
void SMS_Number_Server(void);
void SMS_Number_Mobile(void);
void ReadUPSfromFlash(void);
void SaveUPStoFlash(void);
void ReadLSfromFlash(void);
void SaveLStoFlash(void);

void SCI_Receive(void);

void ReceiveByteRoutine(void);
void TX_Routine(void);

void TX_Mirror(unsigned char TXM_byte);


void My_EE_Write(unsigned char My_EE_Adr,unsigned char My_EE_Data);
unsigned char My_EE_Read(unsigned char My_EE_Adr);
void IntToDec(void);
void ReadKeys(void);
void ADC_Routine(void);

void SetStepMotorStates(void);

void StepUpA(void);
void StepDownA(void);
void StepUpZ(void);
void StepDownZ(void);
void StepUpF(void);
void StepDownF(void);

void MoveToTargetA(void);
void MoveToTargetZ(void);
void MoveToTargetF(void);

void DummyMoving(void);

void FSM_A_Routine(void);
void FSM_Z_Routine(void);
void FSM_F_Routine(void);

void ReadOPTO(void);

main()
{
unsigned char i;

CLRWDT();

IRCF3=1;
IRCF2=1;
IRCF1=1;
IRCF0=1;


PORTA =0b00000000;
TRISA =0b00000001;
ANSELA=0b00000000;

PORTB =0b00000000;
TRISB =0b11111100;
ANSELB=0b00100000;
WPUB  =0b11011100;

PORTC =0b00000000;
TRISC =0b11000000; 

PORTD =0b00000000;
TRISD =0b00000000;
ANSELD=0b00000000;

PORTE =0b00000000;
TRISE =0b00001000;
ANSELE=0b00000000;
WPUE  =0b00001000;

nWPUEN=0;

GIE = 0;
//------------------------------------------------


//------------------------------------------------
FVRCON=0b10000011; // 4.096 V
ADCON1=0b10100011;
//------------------------------------------------

//------------------------------------------------
_delay(10000);

AZ=(My_EE_Read(AZ_Mem)&lt;&lt;8)+My_EE_Read(AZ_Mem+1);
if (AZ&gt;9999) {AZ=100;}
AZtarget=AZ;

OA=(My_EE_Read(OA_Mem)&lt;&lt;8)+My_EE_Read(OA_Mem+1);
if (OA&gt;9999) {OA=0;}
OZ=(My_EE_Read(OZ_Mem)&lt;&lt;8)+My_EE_Read(OZ_Mem+1);
if (OZ&gt;9999) {OZ=0;}
OF=(My_EE_Read(OF_Mem)&lt;&lt;8)+My_EE_Read(OF_Mem+1);
if (OF&gt;9999) {OF=0;}

Init_DA=(My_EE_Read(DA_Mem)&lt;&lt;8)+My_EE_Read(DA_Mem+1);
if (Init_DA&gt;9999) {Init_DA=5000;}
Init_DZ=(My_EE_Read(DZ_Mem)&lt;&lt;8)+My_EE_Read(DZ_Mem+1);
if (Init_DZ&gt;9999) {Init_DZ=5000;}
Init_DF=(My_EE_Read(DF_Mem)&lt;&lt;8)+My_EE_Read(DF_Mem+1);
if (Init_DF&gt;9999) {Init_DF=5000;}


SpeedA=My_EE_Read(SpeedA_Mem);
if (SpeedA&gt;99) {SpeedA=80;}
SpeedZ=My_EE_Read(SpeedZ_Mem);
if (SpeedZ&gt;99) {SpeedZ=80;}
SpeedF=My_EE_Read(SpeedF_Mem);
if (SpeedF&gt;99) {SpeedF=80;}


//------------------------------------------------
TxFSM=0;
RxFSM=0;


//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------


//------------------------------------------------
SPBRG=207;//4800
BAUDCON=0b00000000;
TXSTA=0b00000100;
RCSTA=0b00000000;
SPEN=1;
TXEN=1;
CREN=1;
tempB=RCSTA;
tempB=RCREG;
//------------------------------------------------

//------------------------------------------------
PSA=0;
PS2=0;
PS1=0;
PS0=0;
T0CS=0;
TMR0IE=1;
//------------------------------------------------

GIE = 1;            // enable global interrupts



while (1)
    {
    CLRWDT();


    if (FLAG1msec) // ---------------1msec-------------
        {
        CLRWDT();
        FLAG1msec=0;        
        
        ReadOPTO();

        if (RCIF) {ReceivedByte=RCREG;ReceiveByteRoutine();}

        if (OERR)
            {
            CREN=0;
            CREN=0;
            CREN=1;
            }

        FSM_A_Routine();
        FSM_Z_Routine();
        FSM_F_Routine();

        SetStepMotorStates();

        TX_Routine();


        if ( (AZ==AZtarget) &amp;&amp; (ZE==ZEtarget) &amp;&amp; (FR==FRtarget) ) {Moving=0;}

        if ( (Moving==0) &amp;&amp; (OKpending==1) )
            {
            OKpending=0;
            SendOK=1;
            }
/*
        if ((A_OPTO)&amp;&amp;(AZtarget==0))
            {
            AZ=100;
            AZtarget=AZ;
            }
        if ((Z_OPTO)&amp;&amp;(ZEtarget==0))
            {
            ZE=100;
            ZEtarget=ZE;
            }
*/
//      SpeedAtarget=SpeedA;
//      SpeedZtarget=SpeedZ;
//      SpeedFtarget=SpeedF;
        if (Counter_Speed_A&gt;=5000) {Counter_Speed_A=0;CounterApulse=1;}
        if (Counter_Speed_Z&gt;=5000) {Counter_Speed_Z=0;CounterZpulse=1;}
        if (Counter_Speed_F&gt;=5000) {Counter_Speed_F=0;CounterFpulse=1;}
        



        Counter1msec++;
        if (Counter1msec&gt;9) 
            {Counter1msec=0; // -----------10msec---------      


            if (SpeedAtarget&gt;SpeedAnow) {SpeedAnow++;}
            if (SpeedAtarget&lt;SpeedAnow) {SpeedAnow--;}
            if (SpeedZtarget&gt;SpeedZnow) {SpeedZnow++;}
            if (SpeedZtarget&lt;SpeedZnow) {SpeedZnow--;}
            if (SpeedFtarget&gt;SpeedFnow) {SpeedFnow++;}
            if (SpeedFtarget&lt;SpeedFnow) {SpeedFnow--;}


            if (Timer_FSM_A) {Timer_FSM_A--;}
            if (Timer_FSM_Z) {Timer_FSM_Z--;}
            if (Timer_FSM_F) {Timer_FSM_F--;}


//_____________________________________________________________________________________________
//_____________________________________________________________________________________________
//_____________________________________________________________________________________________
//          DummyMoving();
//_____________________________________________________________________________________________
//_____________________________________________________________________________________________
//_____________________________________________________________________________________________


            Counter10msec++;
            if (Counter10msec&gt;9) 
                {Counter10msec=0; // -----------100msec---------            
            


                Counter100msec++;
                if (Counter100msec&gt;9) 
                    {Counter100msec=0; // -----------1sec---------

                    AZ_Memory=(My_EE_Read(AZ_Mem)&lt;&lt;8)+My_EE_Read(AZ_Mem+1);
                    if (AZ!=AZ_Memory) {My_EE_Write(AZ_Mem,AZ&gt;&gt;8);My_EE_Write(AZ_Mem+1,AZ);}    
    
                    Counter1sec++;
                    if (Counter1sec&gt;59) 
                        {Counter1sec=0; // -----------1min---------
                            


                        }
                    }
                }
            }           
        }
    }
}


/* service routine for timer 0 interrupt */
void interrupt
timer0_isr(void)
{

if (INTF) {INTF=0;}

    if (TMR0IF)  //  100 usec
        {
        TMR0IF = 0;
        TMR0=65;

        Counter100usec++;
        if (Counter100usec&gt;9) {Counter100usec=0;FLAG1msec=1;}

//      ADC_Routine();
        Counter_Speed_A=Counter_Speed_A+SpeedAnow;
        Counter_Speed_Z=Counter_Speed_Z+SpeedZnow;
        Counter_Speed_F=Counter_Speed_F+SpeedFnow;

        }
}


void ReadOPTO(void)
{

A_OPTO_Shift&lt;&lt;=1;
A_OPTO_Shift=A_OPTO_Shift+PIN_A_OPTO;
if (A_OPTO_Shift==0xFFFF) {A_OPTO=1;}
if (A_OPTO_Shift==0x0000) {A_OPTO=0;}

Z_OPTO_Shift&lt;&lt;=1;
Z_OPTO_Shift=Z_OPTO_Shift+PIN_Z_OPTO;
if (Z_OPTO_Shift==0xFFFF) {Z_OPTO=1;}
if (Z_OPTO_Shift==0x0000) {Z_OPTO=0;}

F_OPTO_Shift&lt;&lt;=1;
F_OPTO_Shift=F_OPTO_Shift+PIN_F_OPTO;
if (F_OPTO_Shift==0xFFFF) {F_OPTO=1;}
if (F_OPTO_Shift==0x0000) {F_OPTO=0;}

}



void My_EE_Write(unsigned char My_EE_Adr,unsigned char My_EE_Data)
{
while(WR)continue;
EEADR=My_EE_Adr;
EEDAT=My_EE_Data;
GIE=0;
WREN=1;
EECON2=0x55;
EECON2=0xAA;
WR=1;
WREN=0;
GIE=1;
while(WR)continue;
}
unsigned char My_EE_Read(unsigned char My_EE_Adr)
{
EEADR=My_EE_Adr;
RD=1;
return EEDAT;

}

void IntToDec(void)
{
unsigned int ITDtemp;
ITDtemp=ITD_Input;
ITD_Output[0]=0;
ITD_Output[1]=0;
ITD_Output[2]=0;
ITD_Output[3]=0;
ITD_Output[4]=0;

while (ITDtemp&gt;=10000)
    {
    ITD_Output[4]++;
    ITDtemp=ITDtemp-10000;
    }
while (ITDtemp&gt;=1000)
    {
    ITD_Output[3]++;
    ITDtemp=ITDtemp-1000;
    }
while (ITDtemp&gt;=100)
    {
    ITD_Output[2]++;
    ITDtemp=ITDtemp-100;
    }
while (ITDtemp&gt;=10)
    {
    ITD_Output[1]++;
    ITDtemp=ITDtemp-10;
    }
ITD_Output[0]=ITDtemp;
}


/*

void ADC_Routine(void)
{
switch(ADCFSM)
    {
    case 0:
        I1_Sum_temp=0;
        I2_Sum_temp=0;
        I3_Sum_temp=0;
        I4_Sum_temp=0;
        I5_Sum_temp=0;
        Counter_ADC_Sum=0;
        ADCON0=0b00001101; // AN3 
        ADCFSM=1;
    break;
    case 1:
        ADGO=1;
        ADCFSM=2;
    break;
    case 2:
        ADC_tempResult=0b0000001111111111&amp;ADRES;
        I1_Sum_temp=I1_Sum_temp+ADC_tempResult;
        ADCON0=0b00010001; // AN4 
        ADCFSM=3;
    break;
    case 3:
        ADGO=1;
        ADCFSM=4;
    break;
    case 4:
        ADC_tempResult=0b0000001111111111&amp;ADRES;
        I2_Sum_temp=I2_Sum_temp+ADC_tempResult;
        ADCON0=0b00010101; // AN5 
        ADCFSM=5;
    break;
    case 5:
        ADGO=1;
        ADCFSM=6;
    break;
    case 6:
        ADC_tempResult=0b0000001111111111&amp;ADRES;
        I3_Sum_temp=I3_Sum_temp+ADC_tempResult;
        ADCON0=0b00011001; // AN6 
        ADCFSM=7;
    break;
    case 7:
        ADGO=1;
        ADCFSM=8;
    break;
    case 8:
        ADC_tempResult=0b0000001111111111&amp;ADRES;
        I4_Sum_temp=I4_Sum_temp+ADC_tempResult;
        ADCON0=0b00011101; // AN7 
        ADCFSM=9;
    break;
    case 9:
        ADGO=1;
        ADCFSM=10;
    break;
    case 10:
        ADC_tempResult=0b0000001111111111&amp;ADRES;
        I5_Sum_temp=I5_Sum_temp+ADC_tempResult;
        ADCON0=0b00001101; // AN3 

        Counter_ADC_Sum++;

        if (Counter_ADC_Sum&gt;=120)
            {
            I1_Sum=I1_Sum_temp;
            I2_Sum=I2_Sum_temp;
            I3_Sum=I3_Sum_temp;
            I4_Sum=I4_Sum_temp;
            I5_Sum=I5_Sum_temp;
            I1_Sum_temp=0;
            I2_Sum_temp=0;
            I3_Sum_temp=0;
            I4_Sum_temp=0;
            I5_Sum_temp=0;
            Counter_ADC_Sum=0;
            }
        ADCFSM=1;
    break;
    
    default:
        ADCFSM=0;
    break;
    }
}
*/

void SetStepMotorStates(void)
{

if (StepMotorMatrix[StepMotorStateA]&amp;BIT7) {PIN_A_A1_L=1;} else {PIN_A_A1_L=0;}
if (StepMotorMatrix[StepMotorStateA]&amp;BIT6) {PIN_A_A1_H=1;} else {PIN_A_A1_H=0;}
if (StepMotorMatrix[StepMotorStateA]&amp;BIT5) {PIN_A_A2_L=1;} else {PIN_A_A2_L=0;}
if (StepMotorMatrix[StepMotorStateA]&amp;BIT4) {PIN_A_A2_H=1;} else {PIN_A_A2_H=0;}
if (StepMotorMatrix[StepMotorStateA]&amp;BIT3) {PIN_A_B1_L=1;} else {PIN_A_B1_L=0;}
if (StepMotorMatrix[StepMotorStateA]&amp;BIT2) {PIN_A_B1_H=1;} else {PIN_A_B1_H=0;}
if (StepMotorMatrix[StepMotorStateA]&amp;BIT1) {PIN_A_B2_L=1;} else {PIN_A_B2_L=0;}
if (StepMotorMatrix[StepMotorStateA]&amp;BIT0) {PIN_A_B2_H=1;} else {PIN_A_B2_H=0;}

if (StepMotorMatrix[StepMotorStateZ]&amp;BIT7) {PIN_Z_A1_L=1;} else {PIN_Z_A1_L=0;}
if (StepMotorMatrix[StepMotorStateZ]&amp;BIT6) {PIN_Z_A1_H=1;} else {PIN_Z_A1_H=0;}
if (StepMotorMatrix[StepMotorStateZ]&amp;BIT5) {PIN_Z_A2_L=1;} else {PIN_Z_A2_L=0;}
if (StepMotorMatrix[StepMotorStateZ]&amp;BIT4) {PIN_Z_A2_H=1;} else {PIN_Z_A2_H=0;}
if (StepMotorMatrix[StepMotorStateZ]&amp;BIT3) {PIN_Z_B1_L=1;} else {PIN_Z_B1_L=0;}
if (StepMotorMatrix[StepMotorStateZ]&amp;BIT2) {PIN_Z_B1_H=1;} else {PIN_Z_B1_H=0;}
if (StepMotorMatrix[StepMotorStateZ]&amp;BIT1) {PIN_Z_B2_L=1;} else {PIN_Z_B2_L=0;}
if (StepMotorMatrix[StepMotorStateZ]&amp;BIT0) {PIN_Z_B2_H=1;} else {PIN_Z_B2_H=0;}

if (StepMotorMatrix[StepMotorStateF]&amp;BIT7) {PIN_F_A1_L=1;} else {PIN_F_A1_L=0;}
if (StepMotorMatrix[StepMotorStateF]&amp;BIT6) {PIN_F_A1_H=1;} else {PIN_F_A1_H=0;}
if (StepMotorMatrix[StepMotorStateF]&amp;BIT5) {PIN_F_A2_L=1;} else {PIN_F_A2_L=0;}
if (StepMotorMatrix[StepMotorStateF]&amp;BIT4) {PIN_F_A2_H=1;} else {PIN_F_A2_H=0;}
if (StepMotorMatrix[StepMotorStateF]&amp;BIT3) {PIN_F_B1_L=1;} else {PIN_F_B1_L=0;}
if (StepMotorMatrix[StepMotorStateF]&amp;BIT2) {PIN_F_B1_H=1;} else {PIN_F_B1_H=0;}
if (StepMotorMatrix[StepMotorStateF]&amp;BIT1) {PIN_F_B2_L=1;} else {PIN_F_B2_L=0;}
if (StepMotorMatrix[StepMotorStateF]&amp;BIT0) {PIN_F_B2_H=1;} else {PIN_F_B2_H=0;}

}
/*
void StepUpA(void)
{
if (StepMotorStateA&lt;4) {StepMotorStateA++;} else {StepMotorStateA=1;}
if (AZ&lt;9998) {AZ++;}
}
void StepDownA(void)
{
if (StepMotorStateA&gt;1) {StepMotorStateA--;} else {StepMotorStateA=4;}
if (AZ&gt;1) {AZ--;}
}
*/
void StepUpA(void)
{
if (StepMotorStateA&lt;4) {StepMotorStateA++;} else {StepMotorStateA=1;}
if (AZ&lt;9999) {AZ++;}
}
void StepDownA(void)
{
if (StepMotorStateA&gt;1) {StepMotorStateA--;} else {StepMotorStateA=4;}
if (AZ&gt;0) {AZ--;}
}


void StepUpZ(void)
{
if (StepMotorStateZ&lt;4) {StepMotorStateZ++;} else {StepMotorStateZ=1;}
if (ZE&lt;9999) {ZE++;}
}
void StepDownZ(void)
{
if (StepMotorStateZ&gt;1) {StepMotorStateZ--;} else {StepMotorStateZ=4;}
if (ZE&gt;0) {ZE--;}
}

void StepUpF(void)
{
if (StepMotorStateF&lt;4) {StepMotorStateF++;} else {StepMotorStateF=1;}
if (FR&lt;9999) {FR++;}
}
void StepDownF(void)
{
if (StepMotorStateF&gt;1) {StepMotorStateF--;} else {StepMotorStateF=4;}
if (FR&gt;0) {FR--;}
}


void DummyMoving(void)
{
if (AZ&gt;AZtarget) {AZ--;}
if (AZ&lt;AZtarget) {AZ++;}
if (ZE&gt;ZEtarget) {ZE--;}
if (ZE&lt;ZEtarget) {ZE++;}
if (FR&gt;FRtarget) {FR--;}
if (FR&lt;FRtarget) {FR++;}


}
void MoveToTargetA(void)
{
if (AZ&gt;AZtarget) {StepDownA();}
if (AZ&lt;AZtarget) {StepUpA();}
}
void MoveToTargetZ(void)
{
if (ZE&gt;ZEtarget) {StepDownZ();}
if (ZE&lt;ZEtarget) {StepUpZ();}
}
void MoveToTargetF(void)
{
if (FR&gt;FRtarget) {StepDownF();}
if (FR&lt;FRtarget) {StepUpF();}
}


void ReceiveByteRoutine(void)
{
//ReceiveValid=1;
ReceiveFIFO[19]=ReceiveFIFO[18];
ReceiveFIFO[18]=ReceiveFIFO[17];
ReceiveFIFO[17]=ReceiveFIFO[16];
ReceiveFIFO[16]=ReceiveFIFO[15];
ReceiveFIFO[15]=ReceiveFIFO[14];
ReceiveFIFO[14]=ReceiveFIFO[13];
ReceiveFIFO[13]=ReceiveFIFO[12];
ReceiveFIFO[12]=ReceiveFIFO[11];
ReceiveFIFO[11]=ReceiveFIFO[10];
ReceiveFIFO[10]=ReceiveFIFO[9];
ReceiveFIFO[9]=ReceiveFIFO[8];
ReceiveFIFO[8]=ReceiveFIFO[7];
ReceiveFIFO[7]=ReceiveFIFO[6];
ReceiveFIFO[6]=ReceiveFIFO[5];
ReceiveFIFO[5]=ReceiveFIFO[4];
ReceiveFIFO[4]=ReceiveFIFO[3];
ReceiveFIFO[3]=ReceiveFIFO[2];
ReceiveFIFO[2]=ReceiveFIFO[1];
ReceiveFIFO[1]=ReceiveFIFO[0];
ReceiveFIFO[0]=ReceivedByte;


//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
//TXREG=ReceivedByte;
if (Debug) {TX_Mirror(ReceivedByte);}
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------

if (ReceiveFIFO[0]==13)
        {
        SendLF=1;
        switch(ReceivedBytesCounter)
            {
            case 1:
                if (ReceiveFIFO[1]==&#39;?&#39;)
                    {
                    SendAll=1;
                    }
            break;
            case 2:
                if ( (ReceiveFIFO[1]==&#39;A&#39;) &amp;&amp; (ReceiveFIFO[2]==&#39;D&#39;) ) {GoToTerminalA=1;}
                if ( (ReceiveFIFO[1]==&#39;Z&#39;) &amp;&amp; (ReceiveFIFO[2]==&#39;D&#39;) ) {GoToTerminalZ=1;}
                if ( (ReceiveFIFO[1]==&#39;F&#39;) &amp;&amp; (ReceiveFIFO[2]==&#39;D&#39;) ) {GoToTerminalF=1;}

            break;
            case 3:

                if (ReceiveFIFO[1]==&#39;?&#39;)
                    {
                    if ((ReceiveFIFO[2]==&#39;Z&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;A&#39;)) {SendAZ=1;}
                    if ((ReceiveFIFO[2]==&#39;E&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;Z&#39;)) {SendZE=1;}
                    if ((ReceiveFIFO[2]==&#39;R&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;F&#39;)) {SendFR=1;}

                    if ((ReceiveFIFO[2]==&#39;A&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;O&#39;)) {SendOA=1;}
                    if ((ReceiveFIFO[2]==&#39;Z&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;O&#39;)) {SendOZ=1;}
                    if ((ReceiveFIFO[2]==&#39;F&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;O&#39;)) {SendOF=1;}

                    if ((ReceiveFIFO[2]==&#39;A&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;I&#39;)) {SendDA=1;}
                    if ((ReceiveFIFO[2]==&#39;Z&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;I&#39;)) {SendDZ=1;}
                    if ((ReceiveFIFO[2]==&#39;F&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;I&#39;)) {SendDF=1;}

                    if ((ReceiveFIFO[2]==&#39;A&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;T&#39;)) {SendTA=1;}
                    if ((ReceiveFIFO[2]==&#39;Z&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;T&#39;)) {SendTZ=1;}
                    if ((ReceiveFIFO[2]==&#39;F&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;T&#39;)) {SendTF=1;}

                    if ((ReceiveFIFO[2]==&#39;A&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;S&#39;)) {SendSA=1;}
                    if ((ReceiveFIFO[2]==&#39;Z&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;S&#39;)) {SendSZ=1;}
                    if ((ReceiveFIFO[2]==&#39;F&#39;)&amp;&amp;(ReceiveFIFO[3]==&#39;S&#39;)) {SendSF=1;}

                    }

            break;
            case 4:

                if ( ( (ReceiveFIFO[1]==&#39;P&#39;) &amp;&amp; (ReceiveFIFO[2]==&#39;O&#39;) &amp;&amp; (ReceiveFIFO[3]==&#39;T&#39;) &amp;&amp; (ReceiveFIFO[4]==&#39;S&#39;) )  || ( (ReceiveFIFO[1]==&#39;p&#39;) &amp;&amp; (ReceiveFIFO[2]==&#39;o&#39;) &amp;&amp; (ReceiveFIFO[3]==&#39;t&#39;) &amp;&amp; (ReceiveFIFO[4]==&#39;s&#39;) ) )
                    {
//                  AZtarget=AZ;
//                  ZEtarget=ZE;
//                  FRtarget=FR;
                    StopA=1;
                    StopZ=1;
                    StopF=1;

                    OKpending=0;
                    SendLF=1;
                    }
            break;

            case 5:
                if ( ( (ReceiveFIFO[1]==&#39;G&#39;) &amp;&amp; (ReceiveFIFO[2]==&#39;U&#39;) &amp;&amp; (ReceiveFIFO[3]==&#39;B&#39;) &amp;&amp; (ReceiveFIFO[4]==&#39;E&#39;) &amp;&amp; (ReceiveFIFO[5]==&#39;D&#39;) ) || ( (ReceiveFIFO[1]==&#39;g&#39;) &amp;&amp; (ReceiveFIFO[2]==&#39;u&#39;) &amp;&amp; (ReceiveFIFO[3]==&#39;b&#39;) &amp;&amp; (ReceiveFIFO[4]==&#39;e&#39;) &amp;&amp; (ReceiveFIFO[5]==&#39;d&#39;) ) ) 
                    {
                    if (Debug)
                            {
                            Debug=0;
                            SendDebugOff=1;
                            }
                        else
                            {
                            Debug=1;
                            SendDebugOn=1;
                            }
                    }

                if ( ( (ReceiveFIFO[1]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[2]&gt;=&#39;0&#39;) ) &amp;&amp; ( (ReceiveFIFO[1]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[2]&lt;=&#39;9&#39;) ) )
                    {
                    ReceiveNumber=(ReceiveFIFO[1]-48)+(ReceiveFIFO[2]-48)*10;
                    if ( (ReceiveFIFO[3]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[4]==&#39;A&#39;) &amp;&amp; (ReceiveFIFO[5]==&#39;S&#39;) ) {SpeedA=ReceiveNumber;My_EE_Write(SpeedA_Mem,SpeedA);}
                    if ( (ReceiveFIFO[3]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[4]==&#39;Z&#39;) &amp;&amp; (ReceiveFIFO[5]==&#39;S&#39;) ) {SpeedZ=ReceiveNumber;My_EE_Write(SpeedZ_Mem,SpeedZ);}
                    if ( (ReceiveFIFO[3]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[4]==&#39;F&#39;) &amp;&amp; (ReceiveFIFO[5]==&#39;S&#39;) ) {SpeedF=ReceiveNumber;My_EE_Write(SpeedF_Mem,SpeedF);}
                    SendLF=1;
                    }


            break;

            case 7:
                if ( ( (ReceiveFIFO[1]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[2]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[3]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[4]&gt;=&#39;0&#39;) ) &amp;&amp; ( (ReceiveFIFO[1]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[2]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[3]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[4]&lt;=&#39;9&#39;) ) )
                    {
                    ReceiveNumber=(ReceiveFIFO[1]-48)+(ReceiveFIFO[2]-48)*10+(ReceiveFIFO[3]-48)*100+(ReceiveFIFO[4]-48)*1000;
                    if ( (ReceiveFIFO[5]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;Z&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;A&#39;) ) {AZtarget=ReceiveNumber;OKpending=1;Moving=1;GoToTargetA=1;}
                    if ( (ReceiveFIFO[5]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;E&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;Z&#39;) ) {ZEtarget=ReceiveNumber;OKpending=1;Moving=1;GoToTargetZ=1;}
                    if ( (ReceiveFIFO[5]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;R&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;F&#39;) ) {FRtarget=ReceiveNumber;OKpending=1;Moving=1;GoToTargetF=1;}

                    if ( (ReceiveFIFO[5]==&#39;+&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;Z&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;A&#39;) ) {AZtarget=AZ+ReceiveNumber;OKpending=1;Moving=1;GoToTargetA=1;}
                    if ( (ReceiveFIFO[5]==&#39;+&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;E&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;Z&#39;) ) {ZEtarget=ZE+ReceiveNumber;OKpending=1;Moving=1;GoToTargetZ=1;}
                    if ( (ReceiveFIFO[5]==&#39;+&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;R&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;F&#39;) ) {FRtarget=FR+ReceiveNumber;OKpending=1;Moving=1;GoToTargetF=1;}

                    if ( (ReceiveFIFO[5]==&#39;-&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;Z&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;A&#39;) ) {AZtarget=AZ-ReceiveNumber;OKpending=1;Moving=1;GoToTargetA=1;}
                    if ( (ReceiveFIFO[5]==&#39;-&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;E&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;Z&#39;) ) {ZEtarget=ZE-ReceiveNumber;OKpending=1;Moving=1;GoToTargetZ=1;}
                    if ( (ReceiveFIFO[5]==&#39;-&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;R&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;F&#39;) ) {FRtarget=FR-ReceiveNumber;OKpending=1;Moving=1;GoToTargetF=1;}

                    if ( (ReceiveFIFO[5]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;A&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;O&#39;) ) {OA=ReceiveNumber;My_EE_Write(OA_Mem,OA&gt;&gt;8);My_EE_Write(OA_Mem+1,OA);}
                    if ( (ReceiveFIFO[5]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;Z&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;O&#39;) ) {OZ=ReceiveNumber;My_EE_Write(OZ_Mem,OZ&gt;&gt;8);My_EE_Write(OZ_Mem+1,OZ);}
                    if ( (ReceiveFIFO[5]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;F&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;O&#39;) ) {OF=ReceiveNumber;My_EE_Write(OF_Mem,OF&gt;&gt;8);My_EE_Write(OF_Mem+1,OF);}

                    if ( (ReceiveFIFO[5]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;A&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;I&#39;) ) {Init_DA=ReceiveNumber;My_EE_Write(DA_Mem,Init_DA&gt;&gt;8);My_EE_Write(DA_Mem+1,Init_DA);}
                    if ( (ReceiveFIFO[5]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;Z&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;I&#39;) ) {Init_DZ=ReceiveNumber;My_EE_Write(DZ_Mem,Init_DZ&gt;&gt;8);My_EE_Write(DZ_Mem+1,Init_DZ);}
                    if ( (ReceiveFIFO[5]==&#39;=&#39;) &amp;&amp; (ReceiveFIFO[6]==&#39;F&#39;) &amp;&amp; (ReceiveFIFO[7]==&#39;I&#39;) ) {Init_DF=ReceiveNumber;My_EE_Write(DF_Mem,Init_DF&gt;&gt;8);My_EE_Write(DF_Mem+1,Init_DF);}
                    
                    
                    SendLF=1;
                    }
            break;
            case 12:
                if ( ( (ReceiveFIFO[1]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[2]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[3]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[4]&gt;=&#39;0&#39;) ) &amp;&amp; ( (ReceiveFIFO[1]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[2]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[3]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[4]&lt;=&#39;9&#39;) ) )
                    {
                    if ( ( (ReceiveFIFO[6]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[7]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[8]&gt;=&#39;0&#39;) &amp;&amp; (ReceiveFIFO[9]&gt;=&#39;0&#39;) ) &amp;&amp; ( (ReceiveFIFO[6]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[7]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[8]&lt;=&#39;9&#39;) &amp;&amp; (ReceiveFIFO[9]&lt;=&#39;9&#39;) ) )
                        {
                        if ( (ReceiveFIFO[5]==&#39;,&#39;) &amp;&amp; (ReceiveFIFO[10]==&#39; &#39;) &amp;&amp; (ReceiveFIFO[11]==&#39;O&#39;) &amp;&amp; (ReceiveFIFO[12]==&#39;G&#39;) )
                            {
                            ReceiveNumber=(ReceiveFIFO[1]-48)+(ReceiveFIFO[2]-48)*10+(ReceiveFIFO[3]-48)*100+(ReceiveFIFO[4]-48)*1000;
                            ZEtarget=ReceiveNumber;
                            ReceiveNumber=(ReceiveFIFO[6]-48)+(ReceiveFIFO[7]-48)*10+(ReceiveFIFO[8]-48)*100+(ReceiveFIFO[9]-48)*1000;
                            AZtarget=ReceiveNumber;
                            OKpending=1;
                            Moving=1;
                            GoToTargetA=1;
                            GoToTargetZ=1;                  
                            }
                        }
                    }
            break;
            
            default:

            break;
            }       



        ReceivedBytesCounter=0;
        }   
    else
        {
        ReceivedBytesCounter++;
        }   




}


void TX_Routine(void)
{
if (TXIF)
    {
    switch(TXFSM)
        {
        case 0:

        if (TX_Mirror_Counter)
            {
            TX_Mirror_Counter--;
            TXREG=TX_Mirror_Matrix[0];
            TX_Mirror_Matrix[0]=TX_Mirror_Matrix[1];
            TX_Mirror_Matrix[1]=TX_Mirror_Matrix[2];
            TX_Mirror_Matrix[2]=TX_Mirror_Matrix[3];
            TX_Mirror_Matrix[3]=TX_Mirror_Matrix[4];
            TX_Mirror_Matrix[4]=TX_Mirror_Matrix[5];
            TX_Mirror_Matrix[5]=TX_Mirror_Matrix[6];
            TX_Mirror_Matrix[6]=TX_Mirror_Matrix[7];
            TX_Mirror_Matrix[7]=TX_Mirror_Matrix[8];
            TX_Mirror_Matrix[8]=TX_Mirror_Matrix[9];
            break;
            }

        if (SendLF)
            {
            SendLF=0;
            if (Debug) {TXREG=10;}
            break;
            }
        if (SendAll)
            {
            SendAll=0;
            SendAZ=0;
            SendZE=0;
            SendFR=0;
            if (Debug) {TXREG=10;TXFSM=99;break;} else {TXFSM=100;}
            
            break;
            }
        if (SendAZ)
            {
            SendAZ=0;
            if (Debug) {TXREG=10;}
            TXFSM=101;
            break;
            }
        if (SendZE)
            {
            SendZE=0;
            if (Debug) {TXREG=10;}
            TXFSM=102;
            break;
            }
        if (SendFR)
            {
            SendFR=0;
            if (Debug) {TXREG=10;}
            TXFSM=103;
            break;
            }
        if (SendOA)
            {
            SendOA=0;
            if (Debug) {TXREG=10;}
            TXFSM=110;
            break;
            }
        if (SendOZ)
            {
            SendOZ=0;
            if (Debug) {TXREG=10;}
            TXFSM=111;
            break;
            }
        if (SendOF)
            {
            SendOF=0;
            if (Debug) {TXREG=10;}
            TXFSM=112;
            break;
            }
        if (SendDA)
            {
            SendDA=0;
            if (Debug) {TXREG=10;}
            TXFSM=113;
            break;
            }
        if (SendDZ)
            {
            SendDZ=0;
            if (Debug) {TXREG=10;}
            TXFSM=114;
            break;
            }
        if (SendDF)
            {
            SendDF=0;
            if (Debug) {TXREG=10;}
            TXFSM=115;
            break;
            }

        if (SendTA)
            {
            SendTA=0;
            if (Debug) {TXREG=10;}
            TXFSM=120;
            break;
            }
        if (SendTZ)
            {
            SendTZ=0;
            if (Debug) {TXREG=10;}
            TXFSM=121;
            break;
            }
        if (SendTF)
            {
            SendTF=0;
            if (Debug) {TXREG=10;}
            TXFSM=122;
            break;
            }

        if (SendSA)
            {
            SendSA=0;
            if (Debug) {TXREG=10;}
            TXFSM=130;
            break;
            }
        if (SendSZ)
            {
            SendSZ=0;
            if (Debug) {TXREG=10;}
            TXFSM=131;
            break;
            }
        if (SendSF)
            {
            SendSF=0;
            if (Debug) {TXREG=10;}
            TXFSM=132;
            break;
            }


        if (SendOK)
            {
            SendOK=0;
//          TXREG=10;
            TXFSM=190;
            break;
            }
        if (SendDebugOff)
            {
            SendDebugOff=0;
//          if (Debug) {TXREG=10;}
            TXREG=10;
            TXFSM=200;
            break;
            }
        if (SendDebugOn)
            {
            SendDebugOn=0;
//          if (Debug) {TXREG=10;}
//          TXREG=10;
            TXFSM=210;
            break;
            }

        if (TerminalReachedA)
            {
            TerminalReachedA=0;
            if (Debug) {TXREG=10;}
            TXFSM=140;
            break;
            }
        if (TerminalReachedZ)
            {
            TerminalReachedZ=0;
            if (Debug) {TXREG=10;}
            TXFSM=141;
            break;
            }
        if (TerminalReachedF)
            {
            TerminalReachedF=0;
            if (Debug) {TXREG=10;}
            TXFSM=142;
            break;
            }

        break;

        case 99:
            TX_Counter=0;

            TX_Matrix[0]=&#39;A&#39;;
            TX_Matrix[1]=&#39;Z&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=AZ;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
            TX_Matrix[8]=10;

            TX_Matrix[9]=&#39;Z&#39;;
            TX_Matrix[10]=&#39;E&#39;;
            TX_Matrix[11]=&#39;:&#39;;
            ITD_Input=ZE;
            IntToDec();

            if (PositionValid_Z)
                    {
                    TX_Matrix[12]=ITD_Output[3]+48;
                    TX_Matrix[13]=ITD_Output[2]+48;
                    TX_Matrix[14]=ITD_Output[1]+48;
                    TX_Matrix[15]=ITD_Output[0]+48;
                    }
                else
                    {
                    TX_Matrix[12]=&#39;?&#39;;
                    TX_Matrix[13]=&#39;?&#39;;
                    TX_Matrix[14]=&#39;?&#39;;
                    TX_Matrix[15]=&#39;?&#39;;
                    }
            TX_Matrix[16]=13;
            TX_Matrix[17]=10;

            TX_Matrix[18]=&#39;F&#39;;
            TX_Matrix[19]=&#39;R&#39;;
            TX_Matrix[20]=&#39;:&#39;;
            ITD_Input=FR;
            IntToDec();
            if (PositionValid_F)
                    {
                    TX_Matrix[21]=ITD_Output[3]+48;
                    TX_Matrix[22]=ITD_Output[2]+48;
                    TX_Matrix[23]=ITD_Output[1]+48;
                    TX_Matrix[24]=ITD_Output[0]+48;
                    }
                else
                    {
                    TX_Matrix[21]=&#39;?&#39;;
                    TX_Matrix[22]=&#39;?&#39;;
                    TX_Matrix[23]=&#39;?&#39;;
                    TX_Matrix[24]=&#39;?&#39;;
                    }
            TX_Matrix[25]=13;
            TX_Matrix[26]=10;

            TX_Counter_Max=27;
            TXFSM=250;
        break;      
        case 100:
            TX_Counter=0;

            TX_Matrix[0]=&#39;A&#39;;
            TX_Matrix[1]=&#39;Z&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=AZ;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;

            TX_Matrix[8]=&#39;Z&#39;;
            TX_Matrix[9]=&#39;E&#39;;
            TX_Matrix[10]=&#39;:&#39;;
            ITD_Input=ZE;
            IntToDec();
            TX_Matrix[11]=ITD_Output[3]+48;
            TX_Matrix[12]=ITD_Output[2]+48;
            TX_Matrix[13]=ITD_Output[1]+48;
            TX_Matrix[14]=ITD_Output[0]+48;
            TX_Matrix[15]=13;
//          TX_Matrix[17]=10;

            TX_Matrix[16]=&#39;F&#39;;
            TX_Matrix[17]=&#39;R&#39;;
            TX_Matrix[18]=&#39;:&#39;;
            ITD_Input=FR;
            IntToDec();
            TX_Matrix[19]=ITD_Output[3]+48;
            TX_Matrix[20]=ITD_Output[2]+48;
            TX_Matrix[21]=ITD_Output[1]+48;
            TX_Matrix[22]=ITD_Output[0]+48;
            TX_Matrix[23]=13;
//          TX_Matrix[24]=10;

            TX_Counter_Max=24;
            TXFSM=250;
        break;
        case 101:
            TX_Counter=0;

            TX_Matrix[0]=&#39;A&#39;;
            TX_Matrix[1]=&#39;Z&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=AZ;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 102:
            TX_Counter=0;

            TX_Matrix[0]=&#39;Z&#39;;
            TX_Matrix[1]=&#39;E&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=ZE;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 103:
            TX_Counter=0;

            TX_Matrix[0]=&#39;F&#39;;
            TX_Matrix[1]=&#39;R&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=FR;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 110:
            TX_Counter=0;

            TX_Matrix[0]=&#39;O&#39;;
            TX_Matrix[1]=&#39;A&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=OA;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 111:
            TX_Counter=0;

            TX_Matrix[0]=&#39;O&#39;;
            TX_Matrix[1]=&#39;Z&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=OZ;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 112:
            TX_Counter=0;

            TX_Matrix[0]=&#39;O&#39;;
            TX_Matrix[1]=&#39;F&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=OF;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 113:
            TX_Counter=0;

            TX_Matrix[0]=&#39;I&#39;;
            TX_Matrix[1]=&#39;A&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=Init_DA;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 114:
            TX_Counter=0;

            TX_Matrix[0]=&#39;I&#39;;
            TX_Matrix[1]=&#39;Z&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=Init_DZ;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 115:
            TX_Counter=0;

            TX_Matrix[0]=&#39;I&#39;;
            TX_Matrix[1]=&#39;F&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=Init_DF;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 120:
            TX_Counter=0;

            TX_Matrix[0]=&#39;T&#39;;
            TX_Matrix[1]=&#39;A&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=AZtarget;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 121:
            TX_Counter=0;

            TX_Matrix[0]=&#39;T&#39;;
            TX_Matrix[1]=&#39;Z&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=ZEtarget;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 122:
            TX_Counter=0;

            TX_Matrix[0]=&#39;T&#39;;
            TX_Matrix[1]=&#39;F&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=FRtarget;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;

        case 130:
            TX_Counter=0;

            TX_Matrix[0]=&#39;S&#39;;
            TX_Matrix[1]=&#39;A&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=SpeedA;
            IntToDec();
            TX_Matrix[3]=ITD_Output[1]+48;
            TX_Matrix[4]=ITD_Output[0]+48;
            TX_Matrix[5]=13;
//          TX_Matrix[6]=10;
            TX_Counter_Max=6;
            TXFSM=250;
        break;
        case 131:
            TX_Counter=0;

            TX_Matrix[0]=&#39;S&#39;;
            TX_Matrix[1]=&#39;Z&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=SpeedZ;
            IntToDec();
            TX_Matrix[3]=ITD_Output[1]+48;
            TX_Matrix[4]=ITD_Output[0]+48;
            TX_Matrix[5]=13;
//          TX_Matrix[6]=10;
            TX_Counter_Max=6;
            TXFSM=250;
        break;
        case 132:
            TX_Counter=0;

            TX_Matrix[0]=&#39;S&#39;;
            TX_Matrix[1]=&#39;F&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=SpeedF;
            IntToDec();
            TX_Matrix[3]=ITD_Output[1]+48;
            TX_Matrix[4]=ITD_Output[0]+48;
            TX_Matrix[5]=13;
//          TX_Matrix[6]=10;
            TX_Counter_Max=6;
            TXFSM=250;
        break;

        case 140:
            TX_Counter=0;

            TX_Matrix[0]=&#39;e&#39;;
            TX_Matrix[1]=&#39;A&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=AZterminal;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 141:
            TX_Counter=0;

            TX_Matrix[0]=&#39;e&#39;;
            TX_Matrix[1]=&#39;Z&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=ZEterminal;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;
        case 142:
            TX_Counter=0;

            TX_Matrix[0]=&#39;e&#39;;
            TX_Matrix[1]=&#39;F&#39;;
            TX_Matrix[2]=&#39;:&#39;;
            ITD_Input=FRterminal;
            IntToDec();
            TX_Matrix[3]=ITD_Output[3]+48;
            TX_Matrix[4]=ITD_Output[2]+48;
            TX_Matrix[5]=ITD_Output[1]+48;
            TX_Matrix[6]=ITD_Output[0]+48;
            TX_Matrix[7]=13;
//          TX_Matrix[8]=10;
            TX_Counter_Max=8;
            TXFSM=250;
        break;

        case 190:
            TX_Counter=0;

            TX_Matrix[0]=&#39;O&#39;;
            TX_Matrix[1]=&#39;K&#39;;
            TX_Matrix[2]=13;
//          TX_Matrix[3]=10;

            TX_Counter_Max=3;
            TXFSM=250;
        break;

        case 200:
            TX_Counter=0;

            TX_Matrix[0]=&#39;D&#39;;
            TX_Matrix[1]=&#39;E&#39;;
            TX_Matrix[2]=&#39;B&#39;;
            TX_Matrix[3]=&#39;U&#39;;
            TX_Matrix[4]=&#39;G&#39;;
            TX_Matrix[5]=&#39; &#39;;
            TX_Matrix[6]=&#39;O&#39;;
            TX_Matrix[7]=&#39;F&#39;;
            TX_Matrix[8]=&#39;F&#39;;
            TX_Matrix[9]=13;
//          TX_Matrix[10]=10;

            TX_Counter_Max=10;
            TXFSM=250;
        break;
        case 210:
            TX_Counter=0;

            TX_Matrix[0]=&#39;D&#39;;
            TX_Matrix[1]=&#39;E&#39;;
            TX_Matrix[2]=&#39;B&#39;;
            TX_Matrix[3]=&#39;U&#39;;
            TX_Matrix[4]=&#39;G&#39;;
            TX_Matrix[5]=&#39; &#39;;
            TX_Matrix[6]=&#39;O&#39;;
            TX_Matrix[7]=&#39;N&#39;;
            TX_Matrix[8]=&#39; &#39;;
            TX_Matrix[9]=13;
//          TX_Matrix[10]=10;

            TX_Counter_Max=10;
            TXFSM=250;
        break;

        case 250:
            TXREG=TX_Matrix[TX_Counter];
            TX_Counter++;
            if (TX_Counter==TX_Counter_Max) {TXFSM=251;break;}
        break;
        case 251:
            if (Debug) {TXREG=10;}
            TXFSM=0;
        break;
        
        default:
            TXFSM=0;
        break;
        }
    }
}

void TX_Mirror(unsigned char TXM_byte)
{
if (TX_Mirror_Counter&lt;10)
    {
    TX_Mirror_Matrix[TX_Mirror_Counter]=TXM_byte;
    TX_Mirror_Counter++;
    }
}


void FSM_A_Routine(void)
{
switch (FSM_A)
    {
    case 0:
        SpeedAnow=1;
        GoToTargetA=0;
        TargetReachedA=0;
        GoToTerminalA=0;
        TerminalReachedA=0;
        FSM_A=1;
    break;
    
    case 1:
        if (GoToTerminalA)
            {
            GoToTerminalA=0;
            FSM_A=200;
            break;
            }
        if (GoToTargetA)
            {
            GoToTargetA=0;
            FSM_A=100;
            break;
            }
        if (StopA) {FSM_A=250;break;}
    break;
    
    case 100:
        SpeedAnow=10;
        SpeedAtarget=SpeedA;
        TargetReachedA=0;
        if (AZ&gt;AZtarget) {FSM_A=110;break;}
        if (AZ&lt;AZtarget) {FSM_A=120;break;}
        FSM_A=130;
    break;
    case 110:
        if (StopA) {FSM_A=250;break;}
        if (AZ==AZtarget) {FSM_A=130;break;}

        if (AZ&lt;AZtarget) 
            {
            FSM_A=100;
            break;
            }

        if (CounterApulse)
            {
            CounterApulse=0;
            StepDownA();
            }
        if (AZ-AZtarget&lt;180)
                {
                SpeedAcalc=((AZ-AZtarget)&gt;&gt;1)+20;
                if (SpeedAcalc&gt;SpeedA) {SpeedAcalc=SpeedA;}
                SpeedAtarget=SpeedAcalc;
                }
            else
                {
                SpeedAtarget=SpeedA;
                }
    break;

    case 120:
        if (StopA) {FSM_A=250;break;}
        if (AZ==AZtarget) {FSM_A=130;break;}

        if (AZ&gt;AZtarget) 
            {
            FSM_A=100;
            break;
            }

        if (CounterApulse)
            {
            CounterApulse=0;
            StepUpA();
            }
        if (AZtarget-AZ&lt;180)
                {
                SpeedAcalc=((AZtarget-AZ)&gt;&gt;1)+20;
                if (SpeedAcalc&gt;SpeedA) {SpeedAcalc=SpeedA;}
                SpeedAtarget=SpeedAcalc;
                }
            else
                {
                SpeedAtarget=SpeedA;
                }
    break;

    case 130:
        TargetReachedA=1;
        FSM_A=1;
    break;

    case 200:
        SpeedAnow=10;
        SpeedAtarget=SpeedA;
        TerminalReachedA=0;
        if (A_OPTO==0) {SpeedAnow=10;SpeedAtarget=SpeedA;FSM_A=202;break;}
        if (AZ&lt;9799) {AZtarget_temp=AZ+100;} else {AZtarget_temp=9900;}
        FSM_A=201;
    break;
    case 201:
        if (StopA) {FSM_A=250;break;}
        if (AZ==AZtarget_temp) {SpeedAnow=10;SpeedAtarget=SpeedA;FSM_A=202;break;}

        if (CounterApulse)
            {
            CounterApulse=0;
            StepUpA();
            }
        if (AZtarget_temp-AZ&lt;180)
                {
                SpeedAcalc=((AZtarget_temp-AZ)&gt;&gt;1)+20;
                if (SpeedAcalc&gt;SpeedA) {SpeedAcalc=SpeedA;}
                SpeedAtarget=SpeedAcalc;
                }
            else
                {
                SpeedAtarget=SpeedA;
                }
    break;
    case 202:
        if (StopA) {FSM_A=250;break;}
        if (A_OPTO) {SpeedAnow=5;SpeedAtarget=10;AZtarget_temp=AZ+10;FSM_A=203;break;}

        if (CounterApulse)
            {
            CounterApulse=0;
            StepDownA();
            }
    break;
    case 203:
        if (StopA) {FSM_A=250;break;}
        if (AZ==AZtarget_temp) {SpeedAnow=2;SpeedAtarget=2;FSM_A=204;break;}

        if (CounterApulse)
            {
            CounterApulse=0;
            StepUpA();
            }
    break;
    case 204:
        if (StopA) {FSM_A=250;break;}
        if (A_OPTO) {FSM_A=205;break;}

        if (CounterApulse)
            {
            CounterApulse=0;
            StepDownA();
            }
    break;
    case 205:
        TerminalReachedA=1;
        AZterminal=AZ;
        AZ=Init_DA;
        FSM_A=1;
    break;

    case 250:
        StopA=0;
        TargetReachedA=1;
        FSM_A=1;
    break;

    default:
        FSM_A=0;
    break;
    }

}


void FSM_Z_Routine(void)
{
switch (FSM_Z)
    {
    case 0:
        SpeedZnow=1;
        GoToTargetZ=0;
        TargetReachedZ=0;
        GoToTerminalZ=0;
        TerminalReachedZ=0;
        FSM_Z=1;
    break;
    
    case 1:
        if (GoToTerminalZ)
            {
            GoToTerminalZ=0;
            FSM_Z=200;
            break;
            }
        if (GoToTargetZ)
            {
            GoToTargetZ=0;
            FSM_Z=100;
            break;
            }
        if (StopZ) {FSM_Z=250;break;}
    break;
    
    case 100:
        SpeedZnow=10;
        SpeedZtarget=SpeedZ;
        TargetReachedZ=0;
        if (ZE&gt;ZEtarget) {FSM_Z=110;break;}
        if (ZE&lt;ZEtarget) {FSM_Z=120;break;}
        FSM_Z=130;
    break;
    case 110:
        if (StopZ) {FSM_Z=250;break;}
        if (ZE==ZEtarget) {FSM_Z=130;break;}

        if (ZE&lt;ZEtarget) 
            {
            FSM_Z=100;
            break;
            }

        if (CounterZpulse)
            {
            CounterZpulse=0;
            StepDownZ();
            }
        if (ZE-ZEtarget&lt;180)
                {
                SpeedZcalc=((ZE-ZEtarget)&gt;&gt;1)+20;
                if (SpeedZcalc&gt;SpeedZ) {SpeedZcalc=SpeedZ;}
                SpeedZtarget=SpeedZcalc;
                }
            else
                {
                SpeedZtarget=SpeedZ;
                }
    break;

    case 120:
        if (StopZ) {FSM_Z=250;break;}
        if (ZE==ZEtarget) {FSM_Z=130;break;}

        if (ZE&gt;ZEtarget) 
            {
            FSM_Z=100;
            break;
            }

        if (CounterZpulse)
            {
            CounterZpulse=0;
            StepUpZ();
            }
        if (ZEtarget-ZE&lt;180)
                {
                SpeedZcalc=((ZEtarget-ZE)&gt;&gt;1)+20;
                if (SpeedZcalc&gt;SpeedZ) {SpeedZcalc=SpeedZ;}
                SpeedZtarget=SpeedZcalc;
                }
            else
                {
                SpeedZtarget=SpeedZ;
                }
    break;

    case 130:
        TargetReachedZ=1;
        FSM_Z=1;
    break;

    case 200:
        SpeedZnow=10;
        SpeedZtarget=SpeedZ;
        TerminalReachedZ=0;
        if (Z_OPTO==0) {SpeedZnow=10;SpeedZtarget=SpeedZ;FSM_Z=202;break;}
//      if (ZE&lt;9799) {ZEtarget_temp=ZE+50;} else {ZEtarget_temp=9850;}
        if (ZE&gt;200) {ZEtarget_temp=ZE-100;} else {ZEtarget_temp=100;}
        FSM_Z=201;
    break;
    case 201:
        if (StopZ) {FSM_Z=250;break;}
        if (ZE==ZEtarget_temp) {SpeedZnow=10;SpeedZtarget=SpeedZ;FSM_Z=202;break;}

        if (CounterZpulse)
            {
            CounterZpulse=0;
            StepDownZ();
            }
        if (ZE-ZEtarget_temp&lt;180)
                {
                SpeedZcalc=((ZE-ZEtarget_temp)&gt;&gt;1)+20;
                if (SpeedZcalc&gt;SpeedZ) {SpeedZcalc=SpeedZ;}
                SpeedZtarget=SpeedZcalc;
                }
            else
                {
                SpeedZtarget=SpeedZ;
                }
    break;
    case 202:
        if (StopZ) {FSM_Z=250;break;}
        if (Z_OPTO) {SpeedZnow=5;SpeedZtarget=10;ZEtarget_temp=ZE-10;FSM_Z=203;break;}

        if (CounterZpulse)
            {
            CounterZpulse=0;
            StepUpZ();
            }
    break;
    case 203:
        if (StopZ) {FSM_Z=250;break;}
        if (ZE==ZEtarget_temp) {SpeedZnow=2;SpeedZtarget=2;FSM_Z=204;break;}

        if (CounterZpulse)
            {
            CounterZpulse=0;
            StepDownZ();
            }
    break;
    case 204:
        if (StopZ) {FSM_Z=250;break;}
        if (Z_OPTO) {FSM_Z=205;break;}

        if (CounterZpulse)
            {
            CounterZpulse=0;
            StepUpZ();
            }
    break;
    case 205:
        TerminalReachedZ=1;
        ZEterminal=ZE;
        PositionValid_Z=1;
        ZE=Init_DZ;
        FSM_Z=1;
    break;

    case 250:
        StopZ=0;
        TargetReachedZ=1;
        FSM_Z=1;
    break;

    default:
        FSM_Z=0;
    break;
    }

}
void FSM_F_Routine(void)
{
switch (FSM_F)
    {
    case 0:
        SpeedFnow=1;
        GoToTargetF=0;
        TargetReachedF=0;
        GoToTerminalF=0;
        TerminalReachedF=0;
        FSM_F=1;
    break;
    
    case 1:
        if (GoToTerminalF)
            {
            GoToTerminalF=0;
            FSM_F=200;
            break;
            }
        if (GoToTargetF)
            {
            GoToTargetF=0;
            FSM_F=100;
            break;
            }
        if (StopF) {FSM_F=250;break;}
    break;
    
    case 100:
        SpeedFnow=10;
        SpeedFtarget=SpeedF;
        TargetReachedF=0;
        if (FR&gt;FRtarget) {FSM_F=110;break;}
        if (FR&lt;FRtarget) {FSM_F=120;break;}
        FSM_F=130;
    break;
    case 110:
        if (StopF) {FSM_F=250;break;}
        if (FR==FRtarget) {FSM_F=130;break;}

        if (FR&lt;FRtarget) 
            {
            FSM_F=100;
            break;
            }

        if (CounterFpulse)
            {
            CounterFpulse=0;
            StepDownF();
            }
        if (FR-FRtarget&lt;180)
                {
                SpeedFcalc=((FR-FRtarget)&gt;&gt;1)+20;
                if (SpeedFcalc&gt;SpeedF) {SpeedFcalc=SpeedF;}
                SpeedFtarget=SpeedFcalc;
                }
            else
                {
                SpeedFtarget=SpeedF;
                }
    break;

    case 120:
        if (StopF) {FSM_F=250;break;}
        if (FR==FRtarget) {FSM_F=130;break;}

        if (FR&gt;FRtarget) 
            {
            FSM_F=100;
            break;
            }

        if (CounterFpulse)
            {
            CounterFpulse=0;
            StepUpF();
            }
        if (FRtarget-FR&lt;180)
                {
                SpeedFcalc=((FRtarget-FR)&gt;&gt;1)+20;
                if (SpeedFcalc&gt;SpeedF) {SpeedFcalc=SpeedF;}
                SpeedFtarget=SpeedFcalc;
                }
            else
                {
                SpeedFtarget=SpeedF;
                }
    break;

    case 130:
        TargetReachedF=1;
        FSM_F=1;
    break;

    case 200:
        SpeedFnow=10;
        SpeedFtarget=SpeedF;
        TerminalReachedF=0;
        if (FR&lt;9799) {FRtarget_temp=FR+200;} else {FRtarget_temp=9998;}
        FSM_F=201;
    break;
    case 201:
        if (StopF) {FSM_F=250;break;}
        if (FR==FRtarget_temp) {SpeedFnow=10;SpeedFtarget=SpeedF;FSM_F=202;break;}

        if (CounterFpulse)
            {
            CounterFpulse=0;
            StepUpF();
            }
        if (FRtarget_temp-FR&lt;180)
                {
                SpeedFcalc=((FRtarget_temp-FR)&gt;&gt;1)+20;
                if (SpeedFcalc&gt;SpeedF) {SpeedFcalc=SpeedF;}
                SpeedFtarget=SpeedFcalc;
                }
            else
                {
                SpeedFtarget=SpeedF;
                }
    break;
    case 202:
        if (StopF) {FSM_F=250;break;}
        if (F_OPTO) {SpeedFnow=5;SpeedFtarget=10;FRtarget_temp=FR+10;FSM_F=203;break;}

        if (CounterFpulse)
            {
            CounterFpulse=0;
            StepDownF();
            }
    break;
    case 203:
        if (StopF) {FSM_F=250;break;}
        if (FR==FRtarget_temp) {SpeedFnow=2;SpeedFtarget=2;FSM_F=204;break;}

        if (CounterFpulse)
            {
            CounterFpulse=0;
            StepUpF();
            }
    break;
    case 204:
        if (StopF) {FSM_F=250;break;}
        if (F_OPTO) {FSM_F=205;break;}

        if (CounterFpulse)
            {
            CounterFpulse=0;
            StepDownF();
            }
    break;
    case 205:
        TerminalReachedF=1;
        FRterminal=FR;
        PositionValid_F=1;
        FR=Init_DF;
        FSM_F=1;
    break;

    case 250:
        StopF=0;
        TargetReachedF=1;
        FSM_F=1;
    break;

    default:
        FSM_F=0;
    break;
    }

}</code></pre>

</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": false
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": null,
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["LAP_tracker_manual.pdf"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
},
"number_sections": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
